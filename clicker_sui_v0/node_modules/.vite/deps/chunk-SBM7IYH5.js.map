{
  "version": 3,
  "sources": ["../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/serializer.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/Inputs.ts", "../../.pnpm/valibot@1.2.0_typescript@5.9.3/node_modules/valibot/dist/index.mjs", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/data/internal.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/Commands.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/utils.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/data/v1.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/hash.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/TransactionData.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/experimental/cache.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/version.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/experimental/mvr.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/plugins/NamedPackagesPlugin.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/data/v2.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/jsonRpc/json-rpc-resolver.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/resolve.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/object.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/pure.ts", "../../.pnpm/@mysten+sui@1.45.2_typescript@5.9.3/node_modules/@mysten/sui/src/transactions/Transaction.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { BcsType } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { MOVE_STDLIB_ADDRESS, SUI_FRAMEWORK_ADDRESS } from '../utils/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { OpenMoveTypeSignature, OpenMoveTypeSignatureBody } from './data/internal.js';\n\nconst OBJECT_MODULE_NAME = 'object';\nconst ID_STRUCT_NAME = 'ID';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nexport function isTxContext(param: OpenMoveTypeSignature): boolean {\n\tconst struct =\n\t\ttypeof param.body === 'object' && 'datatype' in param.body ? param.body.datatype : null;\n\n\treturn (\n\t\t!!struct &&\n\t\tnormalizeSuiAddress(struct.package) === normalizeSuiAddress('0x2') &&\n\t\tstruct.module === 'tx_context' &&\n\t\tstruct.type === 'TxContext'\n\t);\n}\n\nexport function getPureBcsSchema(typeSignature: OpenMoveTypeSignatureBody): BcsType<any> | null {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\tif (typeSignature.vector === 'u8') {\n\t\t\treturn bcs.byteVector().transform({\n\t\t\t\tinput: (val: string | Uint8Array) =>\n\t\t\t\t\ttypeof val === 'string' ? new TextEncoder().encode(val) : val,\n\t\t\t\toutput: (val) => val,\n\t\t\t});\n\t\t}\n\t\tconst type = getPureBcsSchema(typeSignature.vector);\n\t\treturn type ? bcs.vector(type) : null;\n\t}\n\n\tif ('datatype' in typeSignature) {\n\t\tconst pkg = normalizeSuiAddress(typeSignature.datatype.package);\n\n\t\tif (pkg === normalizeSuiAddress(MOVE_STDLIB_ADDRESS)) {\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_ASCII_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_ASCII_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_UTF8_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_UTF8_STRUCT_NAME\n\t\t\t) {\n\t\t\t\treturn bcs.String;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttypeSignature.datatype.module === STD_OPTION_MODULE_NAME &&\n\t\t\t\ttypeSignature.datatype.type === STD_OPTION_STRUCT_NAME\n\t\t\t) {\n\t\t\t\tconst type = getPureBcsSchema(typeSignature.datatype.typeParameters[0]);\n\t\t\t\treturn type ? bcs.vector(type) : null;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tpkg === normalizeSuiAddress(SUI_FRAMEWORK_ADDRESS) &&\n\t\t\ttypeSignature.datatype.module === OBJECT_MODULE_NAME &&\n\t\t\ttypeSignature.datatype.type === ID_STRUCT_NAME\n\t\t) {\n\t\t\treturn bcs.Address;\n\t\t}\n\t}\n\n\treturn null;\n}\n\nexport function normalizedTypeToMoveTypeSignature(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignature {\n\tif (typeof type === 'object' && 'Reference' in type) {\n\t\treturn {\n\t\t\tref: '&',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.Reference),\n\t\t};\n\t}\n\tif (typeof type === 'object' && 'MutableReference' in type) {\n\t\treturn {\n\t\t\tref: '&mut',\n\t\t\tbody: normalizedTypeToMoveTypeSignatureBody(type.MutableReference),\n\t\t};\n\t}\n\n\treturn {\n\t\tref: null,\n\t\tbody: normalizedTypeToMoveTypeSignatureBody(type),\n\t};\n}\n\nfunction normalizedTypeToMoveTypeSignatureBody(\n\ttype: SuiMoveNormalizedType,\n): OpenMoveTypeSignatureBody {\n\tif (typeof type === 'string') {\n\t\tswitch (type) {\n\t\t\tcase 'Address':\n\t\t\t\treturn 'address';\n\t\t\tcase 'Bool':\n\t\t\t\treturn 'bool';\n\t\t\tcase 'U8':\n\t\t\t\treturn 'u8';\n\t\t\tcase 'U16':\n\t\t\t\treturn 'u16';\n\t\t\tcase 'U32':\n\t\t\t\treturn 'u32';\n\t\t\tcase 'U64':\n\t\t\t\treturn 'u64';\n\t\t\tcase 'U128':\n\t\t\t\treturn 'u128';\n\t\t\tcase 'U256':\n\t\t\t\treturn 'u256';\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected type ${type}`);\n\t\t}\n\t}\n\n\tif ('Vector' in type) {\n\t\treturn { vector: normalizedTypeToMoveTypeSignatureBody(type.Vector) };\n\t}\n\n\tif ('Struct' in type) {\n\t\treturn {\n\t\t\tdatatype: {\n\t\t\t\tpackage: type.Struct.address,\n\t\t\t\tmodule: type.Struct.module,\n\t\t\t\ttype: type.Struct.name,\n\t\t\t\ttypeParameters: type.Struct.typeArguments.map(normalizedTypeToMoveTypeSignatureBody),\n\t\t\t},\n\t\t};\n\t}\n\n\tif ('TypeParameter' in type) {\n\t\treturn { typeParameter: type.TypeParameter };\n\t}\n\n\tthrow new Error(`Unexpected type ${JSON.stringify(type)}`);\n}\n\nexport function pureBcsSchemaFromOpenMoveTypeSignatureBody(\n\ttypeSignature: OpenMoveTypeSignatureBody,\n): BcsType<any> {\n\tif (typeof typeSignature === 'string') {\n\t\tswitch (typeSignature) {\n\t\t\tcase 'address':\n\t\t\t\treturn bcs.Address;\n\t\t\tcase 'bool':\n\t\t\t\treturn bcs.Bool;\n\t\t\tcase 'u8':\n\t\t\t\treturn bcs.U8;\n\t\t\tcase 'u16':\n\t\t\t\treturn bcs.U16;\n\t\t\tcase 'u32':\n\t\t\t\treturn bcs.U32;\n\t\t\tcase 'u64':\n\t\t\t\treturn bcs.U64;\n\t\t\tcase 'u128':\n\t\t\t\treturn bcs.U128;\n\t\t\tcase 'u256':\n\t\t\t\treturn bcs.U256;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown type signature ${typeSignature}`);\n\t\t}\n\t}\n\n\tif ('vector' in typeSignature) {\n\t\treturn bcs.vector(pureBcsSchemaFromOpenMoveTypeSignatureBody(typeSignature.vector));\n\t}\n\n\tthrow new Error(`Expected pure typeSignature, but got ${JSON.stringify(typeSignature)}`);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { CallArg, ObjectRef } from './data/internal.js';\n\nfunction Pure(data: Uint8Array | SerializedBcs<any>): Extract<CallArg, { Pure: unknown }> {\n\treturn {\n\t\t$kind: 'Pure',\n\t\tPure: {\n\t\t\tbytes: data instanceof Uint8Array ? toBase64(data) : data.toBase64(),\n\t\t},\n\t};\n}\n\nexport const Inputs = {\n\tPure,\n\tObjectRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'ImmOrOwnedObject',\n\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tSharedObjectRef({\n\t\tobjectId,\n\t\tmutable,\n\t\tinitialSharedVersion,\n\t}: {\n\t\tobjectId: string;\n\t\tmutable: boolean;\n\t\tinitialSharedVersion: number | string;\n\t}): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'SharedObject',\n\t\t\t\tSharedObject: {\n\t\t\t\t\tmutable,\n\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n\tReceivingRef({ objectId, digest, version }: ObjectRef): Extract<CallArg, { Object: unknown }> {\n\t\treturn {\n\t\t\t$kind: 'Object',\n\t\t\tObject: {\n\t\t\t\t$kind: 'Receiving',\n\t\t\t\tReceiving: {\n\t\t\t\t\tdigest,\n\t\t\t\t\tversion,\n\t\t\t\t\tobjectId: normalizeSuiAddress(objectId),\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\t},\n};\n", "//#region src/storages/globalConfig/globalConfig.ts\nlet store$4;\n/**\n* Sets the global configuration.\n*\n* @param config The configuration.\n*/\nfunction setGlobalConfig(config$1) {\n\tstore$4 = {\n\t\t...store$4,\n\t\t...config$1\n\t};\n}\n/**\n* Returns the global configuration.\n*\n* @param config The config to merge.\n*\n* @returns The configuration.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalConfig(config$1) {\n\treturn {\n\t\tlang: config$1?.lang ?? store$4?.lang,\n\t\tmessage: config$1?.message,\n\t\tabortEarly: config$1?.abortEarly ?? store$4?.abortEarly,\n\t\tabortPipeEarly: config$1?.abortPipeEarly ?? store$4?.abortPipeEarly\n\t};\n}\n/**\n* Deletes the global configuration.\n*/\nfunction deleteGlobalConfig() {\n\tstore$4 = void 0;\n}\n\n//#endregion\n//#region src/storages/globalMessage/globalMessage.ts\nlet store$3;\n/**\n* Sets a global error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setGlobalMessage(message$1, lang) {\n\tif (!store$3) store$3 = /* @__PURE__ */ new Map();\n\tstore$3.set(lang, message$1);\n}\n/**\n* Returns a global error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getGlobalMessage(lang) {\n\treturn store$3?.get(lang);\n}\n/**\n* Deletes a global error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteGlobalMessage(lang) {\n\tstore$3?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/schemaMessage/schemaMessage.ts\nlet store$2;\n/**\n* Sets a schema error message.\n*\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSchemaMessage(message$1, lang) {\n\tif (!store$2) store$2 = /* @__PURE__ */ new Map();\n\tstore$2.set(lang, message$1);\n}\n/**\n* Returns a schema error message.\n*\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSchemaMessage(lang) {\n\treturn store$2?.get(lang);\n}\n/**\n* Deletes a schema error message.\n*\n* @param lang The language of the message.\n*/\nfunction deleteSchemaMessage(lang) {\n\tstore$2?.delete(lang);\n}\n\n//#endregion\n//#region src/storages/specificMessage/specificMessage.ts\nlet store$1;\n/**\n* Sets a specific error message.\n*\n* @param reference The identifier reference.\n* @param message The error message.\n* @param lang The language of the message.\n*/\nfunction setSpecificMessage(reference, message$1, lang) {\n\tif (!store$1) store$1 = /* @__PURE__ */ new Map();\n\tif (!store$1.get(reference)) store$1.set(reference, /* @__PURE__ */ new Map());\n\tstore$1.get(reference).set(lang, message$1);\n}\n/**\n* Returns a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*\n* @returns The error message.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getSpecificMessage(reference, lang) {\n\treturn store$1?.get(reference)?.get(lang);\n}\n/**\n* Deletes a specific error message.\n*\n* @param reference The identifier reference.\n* @param lang The language of the message.\n*/\nfunction deleteSpecificMessage(reference, lang) {\n\tstore$1?.get(reference)?.delete(lang);\n}\n\n//#endregion\n//#region src/utils/_stringify/_stringify.ts\n/**\n* Stringifies an unknown input to a literal or type string.\n*\n* @param input The unknown input.\n*\n* @returns A literal or type string.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _stringify(input) {\n\tconst type = typeof input;\n\tif (type === \"string\") return `\"${input}\"`;\n\tif (type === \"number\" || type === \"bigint\" || type === \"boolean\") return `${input}`;\n\tif (type === \"object\" || type === \"function\") return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n\treturn type;\n}\n\n//#endregion\n//#region src/utils/_addIssue/_addIssue.ts\n/**\n* Adds an issue to the dataset.\n*\n* @param context The issue context.\n* @param label The issue label.\n* @param dataset The input dataset.\n* @param config The configuration.\n* @param other The optional props.\n*\n* @internal\n*/\nfunction _addIssue(context, label, dataset, config$1, other) {\n\tconst input = other && \"input\" in other ? other.input : dataset.value;\n\tconst expected = other?.expected ?? context.expects ?? null;\n\tconst received = other?.received ?? /* @__PURE__ */ _stringify(input);\n\tconst issue = {\n\t\tkind: context.kind,\n\t\ttype: context.type,\n\t\tinput,\n\t\texpected,\n\t\treceived,\n\t\tmessage: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n\t\trequirement: context.requirement,\n\t\tpath: other?.path,\n\t\tissues: other?.issues,\n\t\tlang: config$1.lang,\n\t\tabortEarly: config$1.abortEarly,\n\t\tabortPipeEarly: config$1.abortPipeEarly\n\t};\n\tconst isSchema = context.kind === \"schema\";\n\tconst message$1 = other?.message ?? context.message ?? /* @__PURE__ */ getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? /* @__PURE__ */ getSchemaMessage(issue.lang) : null) ?? config$1.message ?? /* @__PURE__ */ getGlobalMessage(issue.lang);\n\tif (message$1 !== void 0) issue.message = typeof message$1 === \"function\" ? message$1(issue) : message$1;\n\tif (isSchema) dataset.typed = false;\n\tif (dataset.issues) dataset.issues.push(issue);\n\telse dataset.issues = [issue];\n}\n\n//#endregion\n//#region src/utils/_getByteCount/_getByteCount.ts\nlet textEncoder;\n/**\n* Returns the byte count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The byte count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getByteCount(input) {\n\tif (!textEncoder) textEncoder = new TextEncoder();\n\treturn textEncoder.encode(input).length;\n}\n\n//#endregion\n//#region src/utils/_getGraphemeCount/_getGraphemeCount.ts\nlet segmenter;\n/**\n* Returns the grapheme count of the input.\n*\n* @param input The input to be measured.\n*\n* @returns The grapheme count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getGraphemeCount(input) {\n\tif (!segmenter) segmenter = new Intl.Segmenter();\n\tconst segments = segmenter.segment(input);\n\tlet count = 0;\n\tfor (const _ of segments) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_getLastMetadata/_getLastMetadata.ts\n/**\n* Returns the last top-level value of a given metadata type from a schema\n* using a breadth-first search that starts with the last item in the pipeline.\n*\n* @param schema The schema to search.\n* @param type The metadata type.\n*\n* @returns The value, if any.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getLastMetadata(schema, type) {\n\tif (\"pipe\" in schema) {\n\t\tconst nestedSchemas = [];\n\t\tfor (let index = schema.pipe.length - 1; index >= 0; index--) {\n\t\t\tconst item = schema.pipe[index];\n\t\t\tif (item.kind === \"schema\" && \"pipe\" in item) nestedSchemas.push(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === type) return item[type];\n\t\t}\n\t\tfor (const nestedSchema of nestedSchemas) {\n\t\t\tconst result = /* @__PURE__ */ _getLastMetadata(nestedSchema, type);\n\t\t\tif (result !== void 0) return result;\n\t\t}\n\t}\n}\n\n//#endregion\n//#region src/utils/_getStandardProps/_getStandardProps.ts\n/**\n* Returns the Standard Schema properties.\n*\n* @param context The schema context.\n*\n* @returns The Standard Schema properties.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getStandardProps(context) {\n\treturn {\n\t\tversion: 1,\n\t\tvendor: \"valibot\",\n\t\tvalidate(value$1) {\n\t\t\treturn context[\"~run\"]({ value: value$1 }, /* @__PURE__ */ getGlobalConfig());\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/utils/_getWordCount/_getWordCount.ts\nlet store;\n/**\n* Returns the word count of the input.\n*\n* @param locales The locales to be used.\n* @param input The input to be measured.\n*\n* @returns The word count.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _getWordCount(locales, input) {\n\tif (!store) store = /* @__PURE__ */ new Map();\n\tif (!store.get(locales)) store.set(locales, new Intl.Segmenter(locales, { granularity: \"word\" }));\n\tconst segments = store.get(locales).segment(input);\n\tlet count = 0;\n\tfor (const segment of segments) if (segment.isWordLike) count++;\n\treturn count;\n}\n\n//#endregion\n//#region src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\n/**\n* Non-digit regex.\n*/\nconst NON_DIGIT_REGEX = /\\D/gu;\n/**\n* Checks whether a string with numbers corresponds to the luhn algorithm.\n*\n* @param input The input to be checked.\n*\n* @returns Whether input is valid.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isLuhnAlgo(input) {\n\tconst number$1 = input.replace(NON_DIGIT_REGEX, \"\");\n\tlet length$1 = number$1.length;\n\tlet bit = 1;\n\tlet sum = 0;\n\twhile (length$1) {\n\t\tconst value$1 = +number$1[--length$1];\n\t\tbit ^= 1;\n\t\tsum += bit ? [\n\t\t\t0,\n\t\t\t2,\n\t\t\t4,\n\t\t\t6,\n\t\t\t8,\n\t\t\t1,\n\t\t\t3,\n\t\t\t5,\n\t\t\t7,\n\t\t\t9\n\t\t][value$1] : value$1;\n\t}\n\treturn sum % 10 === 0;\n}\n\n//#endregion\n//#region src/utils/_isValidObjectKey/_isValidObjectKey.ts\n/**\n* Disallows inherited object properties and prevents object prototype\n* pollution by disallowing certain keys.\n*\n* @param object The object to check.\n* @param key The key to check.\n*\n* @returns Whether the key is allowed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isValidObjectKey(object$1, key) {\n\treturn Object.hasOwn(object$1, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n//#endregion\n//#region src/utils/_joinExpects/_joinExpects.ts\n/**\n* Joins multiple `expects` values with the given separator.\n*\n* @param values The `expects` values.\n* @param separator The separator.\n*\n* @returns The joined `expects` property.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _joinExpects(values$1, separator) {\n\tconst list = [...new Set(values$1)];\n\tif (list.length > 1) return `(${list.join(` ${separator} `)})`;\n\treturn list[0] ?? \"never\";\n}\n\n//#endregion\n//#region src/utils/entriesFromList/entriesFromList.ts\n/**\n* Creates an object entries definition from a list of keys and a schema.\n*\n* @param list A list of keys.\n* @param schema The schema of the keys.\n*\n* @returns The object entries.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromList(list, schema) {\n\tconst entries$1 = {};\n\tfor (const key of list) entries$1[key] = schema;\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/entriesFromObjects/entriesFromObjects.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entriesFromObjects(schemas) {\n\tconst entries$1 = {};\n\tfor (const schema of schemas) Object.assign(entries$1, schema.entries);\n\treturn entries$1;\n}\n\n//#endregion\n//#region src/utils/getDotPath/getDotPath.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDotPath(issue) {\n\tif (issue.path) {\n\t\tlet key = \"\";\n\t\tfor (const item of issue.path) if (typeof item.key === \"string\" || typeof item.key === \"number\") if (key) key += `.${item.key}`;\n\t\telse key += item.key;\n\t\telse return null;\n\t\treturn key;\n\t}\n\treturn null;\n}\n\n//#endregion\n//#region src/utils/isOfKind/isOfKind.ts\n/**\n* A generic type guard to check the kind of an object.\n*\n* @param kind The kind to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfKind(kind, object$1) {\n\treturn object$1.kind === kind;\n}\n\n//#endregion\n//#region src/utils/isOfType/isOfType.ts\n/**\n* A generic type guard to check the type of an object.\n*\n* @param type The type to check for.\n* @param object The object to check.\n*\n* @returns Whether it matches.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isOfType(type, object$1) {\n\treturn object$1.type === type;\n}\n\n//#endregion\n//#region src/utils/isValiError/isValiError.ts\n/**\n* A type guard to check if an error is a ValiError.\n*\n* @param error The error to check.\n*\n* @returns Whether its a ValiError.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction isValiError(error) {\n\treturn error instanceof ValiError;\n}\n\n//#endregion\n//#region src/utils/ValiError/ValiError.ts\n/**\n* A Valibot error with useful information.\n*/\nvar ValiError = class extends Error {\n\t/**\n\t* Creates a Valibot error with useful information.\n\t*\n\t* @param issues The error issues.\n\t*/\n\tconstructor(issues) {\n\t\tsuper(issues[0].message);\n\t\tthis.name = \"ValiError\";\n\t\tthis.issues = issues;\n\t}\n};\n\n//#endregion\n//#region src/actions/args/args.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction args(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: args,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst argsDataset = this.schema[\"~run\"]({ value: args_ }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/args/argsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction argsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"args\",\n\t\treference: argsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args$1) => {\n\t\t\t\tconst argsDataset = await schema[\"~run\"]({ value: args$1 }, config$1);\n\t\t\t\tif (argsDataset.issues) throw new ValiError(argsDataset.issues);\n\t\t\t\treturn func(...argsDataset.value);\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/await/awaitAsync.ts\n/**\n* Creates an await transformation action.\n*\n* @returns An await action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction awaitAsync() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"await\",\n\t\treference: awaitAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/regex.ts\n/**\n* [Base64](https://en.wikipedia.org/wiki/Base64) regex.\n*/\nconst BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\n/**\n* [BIC](https://en.wikipedia.org/wiki/ISO_9362) regex.\n*/\nconst BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\n/**\n* [Cuid2](https://github.com/paralleldrive/cuid2) regex.\n*/\nconst CUID2_REGEX = /^[a-z][\\da-z]*$/u;\n/**\n* [Decimal](https://en.wikipedia.org/wiki/Decimal) regex.\n*/\nconst DECIMAL_REGEX = /^[+-]?(?:\\d*\\.)?\\d+$/u;\n/**\n* [Digits](https://en.wikipedia.org/wiki/Numerical_digit) regex.\n*/\nconst DIGITS_REGEX = /^\\d+$/u;\n/**\n* [Email address](https://en.wikipedia.org/wiki/Email_address) regex.\n*/\nconst EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\n/**\n* Emoji regex from [emoji-regex-xs](https://github.com/slevithan/emoji-regex-xs) v1.0.0 (MIT license).\n*\n* Hint: We decided against the newer `/^\\p{RGI_Emoji}+$/v` regex because it is\n* not supported in older runtimes and does not match all emoji.\n*/\nconst EMOJI_REGEX = /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|(?![\\p{Emoji_Modifier_Base}\\u{1F1E6}-\\u{1F1FF}])\\p{Emoji_Presentation}))*)+$/u;\n/**\n* [Hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-fA-F]+$/u;\n/**\n* [Hex color](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst HEX_COLOR_REGEX = /^#(?:[\\da-fA-F]{3,4}|[\\da-fA-F]{6}|[\\da-fA-F]{8})$/u;\n/**\n* [IMEI](https://en.wikipedia.org/wiki/International_Mobile_Equipment_Identity) regex.\n*/\nconst IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\n/**\n* [IPv4](https://en.wikipedia.org/wiki/IPv4) regex.\n*/\nconst IPV4_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\n/**\n* [IPv6](https://en.wikipedia.org/wiki/IPv6) regex.\n*/\nconst IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [IP](https://en.wikipedia.org/wiki/IP_address) regex.\n*/\nconst IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date regex.\n*/\nconst ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) date-time regex.\n*/\nconst ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time regex.\n*/\nconst ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) time with seconds regex.\n*/\nconst ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) timestamp regex.\n*/\nconst ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])[T ](?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\n/**\n* [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) week regex.\n*/\nconst ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 48 bit regex.\n*/\nconst MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) 64 bit regex.\n*/\nconst MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [MAC](https://en.wikipedia.org/wiki/MAC_address) regex.\n*/\nconst MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\n/**\n* [Nano ID](https://github.com/ai/nanoid) regex.\n*/\nconst NANO_ID_REGEX = /^[\\w-]+$/u;\n/**\n* [Octal](https://en.wikipedia.org/wiki/Octal) regex.\n*/\nconst OCTAL_REGEX = /^(?:0o)?[0-7]+$/u;\n/**\n* [RFC 5322 email address](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1) regex.\n*\n* Hint: This regex was taken from the [HTML Living Standard Specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) and does not perfectly represent RFC 5322.\n*/\nconst RFC_EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/**\n* [Slug](https://en.wikipedia.org/wiki/Clean_URL#Slug) regex.\n*/\nconst SLUG_REGEX = /^[\\da-z]+(?:[-_][\\da-z]+)*$/u;\n/**\n* [ULID](https://github.com/ulid/spec) regex.\n*\n* Hint: We decided against the `i` flag for better JSON Schema compatibility.\n*/\nconst ULID_REGEX = /^[\\da-hjkmnp-tv-zA-HJKMNP-TV-Z]{26}$/u;\n/**\n* [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) regex.\n*/\nconst UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n//#endregion\n//#region src/actions/base64/base64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction base64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"base64\",\n\t\treference: base64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BASE64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Base64\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bic/bic.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bic(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bic\",\n\t\treference: bic,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: BIC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"BIC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/brand/brand.ts\n/**\n* Creates a brand transformation action.\n*\n* @param name The brand name.\n*\n* @returns A brand action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction brand(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"brand\",\n\t\treference: brand,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/bytes/bytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"bytes\",\n\t\treference: bytes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 !== this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/check.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction check(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: check,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/check/checkAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check\",\n\t\treference: checkAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItems(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItems,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) for (let index = 0; index < dataset.value.length; index++) {\n\t\t\t\tconst item = dataset.value[index];\n\t\t\t\tif (!this.requirement(item, index, dataset.value)) _addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\tinput: item,\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\tvalue: item\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/checkItems/checkItemsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction checkItemsAsync(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"check_items\",\n\t\treference: checkItemsAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst requirementResults = await Promise.all(dataset.value.map(this.requirement));\n\t\t\t\tfor (let index = 0; index < dataset.value.length; index++) if (!requirementResults[index]) {\n\t\t\t\t\tconst item = dataset.value[index];\n\t\t\t\t\t_addIssue(this, \"item\", dataset, config$1, {\n\t\t\t\t\t\tinput: item,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: dataset.value,\n\t\t\t\t\t\t\tkey: index,\n\t\t\t\t\t\t\tvalue: item\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/creditCard/creditCard.ts\n/**\n* Credit card regex.\n*/\nconst CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\n/**\n* Sanitize regex.\n*/\nconst SANITIZE_REGEX = /[- ]/gu;\n/**\n* Provider regex list.\n*/\nconst PROVIDER_REGEX_LIST = [\n\t/^3[47]\\d{13}$/u,\n\t/^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n\t/^6(?:011|5\\d{2})\\d{12,15}$/u,\n\t/^(?:2131|1800|35\\d{3})\\d{11}$/u,\n\t/^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n\t/^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n\t/^4\\d{12}(?:\\d{3,6})?$/u\n];\n/* @__NO_SIDE_EFFECTS__ */\nfunction creditCard(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"credit_card\",\n\t\treference: creditCard,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\tlet sanitized;\n\t\t\treturn CREDIT_CARD_REGEX.test(input) && (sanitized = input.replace(SANITIZE_REGEX, \"\")) && PROVIDER_REGEX_LIST.some((regex$1) => regex$1.test(sanitized)) && /* @__PURE__ */ _isLuhnAlgo(sanitized);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"credit card\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/cuid2/cuid2.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction cuid2(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"cuid2\",\n\t\treference: cuid2,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: CUID2_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Cuid2\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/decimal/decimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction decimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"decimal\",\n\t\treference: decimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"decimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/description/description.ts\n/**\n* Creates a description metadata action.\n*\n* @param description_ The description text.\n*\n* @returns A description action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction description(description_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"description\",\n\t\treference: description,\n\t\tdescription: description_\n\t};\n}\n\n//#endregion\n//#region src/actions/digits/digits.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction digits(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"digits\",\n\t\treference: digits,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: DIGITS_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"digits\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/email/email.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction email(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"email\",\n\t\treference: email,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/emoji/emoji.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction emoji(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"emoji\",\n\t\treference: emoji,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: EMOJI_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"emoji\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/empty/empty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction empty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"empty\",\n\t\treference: empty,\n\t\tasync: false,\n\t\texpects: \"0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > 0) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/endsWith/endsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction endsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ends_with\",\n\t\treference: endsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.endsWith(this.requirement)) _addIssue(this, \"end\", dataset, config$1, { received: `\"${dataset.value.slice(-this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/entries/entries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction entries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"entries\",\n\t\treference: entries,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count !== this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/everyItem/everyItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction everyItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"every_item\",\n\t\treference: everyItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.every(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/examples/examples.ts\n/**\n* Creates an examples metadata action.\n*\n* @param examples_ The examples.\n*\n* @returns An examples action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction examples(examples_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"examples\",\n\t\treference: examples,\n\t\texamples: examples_\n\t};\n}\n\n//#endregion\n//#region src/actions/excludes/excludes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction excludes(requirement, message$1) {\n\tconst received = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"excludes\",\n\t\treference: excludes,\n\t\tasync: false,\n\t\texpects: `!${received}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/filterItems/filterItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction filterItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"filter_items\",\n\t\treference: filterItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.filter(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/findItem/findItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction findItem(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"find_item\",\n\t\treference: findItem,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.find(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/finite/finite.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction finite(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"finite\",\n\t\treference: finite,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isFinite,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"finite\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/flavor/flavor.ts\n/**\n* Creates a flavor transformation action.\n*\n* @param name The flavor name.\n*\n* @returns A flavor action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction flavor(name) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"flavor\",\n\t\treference: flavor,\n\t\tasync: false,\n\t\tname,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/graphemes/graphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction graphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"graphemes\",\n\t\treference: graphemes,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/gtValue/gtValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction gtValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"gt_value\",\n\t\treference: gtValue,\n\t\tasync: false,\n\t\texpects: `>${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value > this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hash/hash.ts\n/**\n* Hash lengths object.\n*/\nconst HASH_LENGTHS = {\n\tmd4: 32,\n\tmd5: 32,\n\tsha1: 40,\n\tsha256: 64,\n\tsha384: 96,\n\tsha512: 128,\n\tripemd128: 32,\n\tripemd160: 40,\n\ttiger128: 32,\n\ttiger160: 40,\n\ttiger192: 48,\n\tcrc32: 8,\n\tcrc32b: 8,\n\tadler32: 8\n};\n/* @__NO_SIDE_EFFECTS__ */\nfunction hash(types, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hash\",\n\t\treference: hash,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RegExp(types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hash\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexadecimal/hexadecimal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexadecimal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hexadecimal\",\n\t\treference: hexadecimal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEXADECIMAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hexadecimal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/hexColor/hexColor.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction hexColor(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"hex_color\",\n\t\treference: hexColor,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: HEX_COLOR_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"hex color\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/imei/imei.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction imei(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"imei\",\n\t\treference: imei,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\treturn IMEI_REGEX.test(input) && /* @__PURE__ */ _isLuhnAlgo(input);\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"IMEI\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/includes/includes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction includes(requirement, message$1) {\n\tconst expects = /* @__PURE__ */ _stringify(requirement);\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"includes\",\n\t\treference: includes,\n\t\tasync: false,\n\t\texpects,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.includes(this.requirement)) _addIssue(this, \"content\", dataset, config$1, { received: `!${expects}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/integer/integer.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction integer(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"integer\",\n\t\treference: integer,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ip/ip.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ip(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ip\",\n\t\treference: ip,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IP\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv4/ipv4.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv4(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv4\",\n\t\treference: ipv4,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV4_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv4\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ipv6/ipv6.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ipv6(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ipv6\",\n\t\treference: ipv6,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: IPV6_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"IPv6\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDate/isoDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDate(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date\",\n\t\treference: isoDate,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoDateTime/isoDateTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoDateTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_date_time\",\n\t\treference: isoDateTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_DATE_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"date-time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTime/isoTime.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTime(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time\",\n\t\treference: isoTime,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimeSecond/isoTimeSecond.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimeSecond(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_time_second\",\n\t\treference: isoTimeSecond,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIME_SECOND_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"time-second\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoTimestamp/isoTimestamp.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoTimestamp(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_timestamp\",\n\t\treference: isoTimestamp,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_TIMESTAMP_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"timestamp\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/isoWeek/isoWeek.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction isoWeek(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"iso_week\",\n\t\treference: isoWeek,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ISO_WEEK_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"week\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/length/length.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction length(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"length\",\n\t\treference: length,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length !== this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ltValue/ltValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ltValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"lt_value\",\n\t\treference: ltValue,\n\t\tasync: false,\n\t\texpects: `<${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value < this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac/mac.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac\",\n\t\treference: mac,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac48/mac48.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac48(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac48\",\n\t\treference: mac48,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC48_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"48-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mac64/mac64.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mac64(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mac64\",\n\t\treference: mac64,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: MAC64_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"64-bit MAC\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/mapItems/mapItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"map_items\",\n\t\treference: mapItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.map(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxBytes/maxBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_bytes\",\n\t\treference: maxBytes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 > this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxEntries/maxEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_entries\",\n\t\treference: maxEntries,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count > this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxGraphemes/maxGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_graphemes\",\n\t\treference: maxGraphemes,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxLength/maxLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_length\",\n\t\treference: maxLength,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length > this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxSize/maxSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_size\",\n\t\treference: maxSize,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size > this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxValue/maxValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_value\",\n\t\treference: maxValue,\n\t\tasync: false,\n\t\texpects: `<=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value <= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/maxWords/maxWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction maxWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"max_words\",\n\t\treference: maxWords,\n\t\tasync: false,\n\t\texpects: `<=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count > this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/metadata/metadata.ts\n/**\n* Creates a custom metadata action.\n*\n* @param metadata_ The metadata object.\n*\n* @returns A metadata action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction metadata(metadata_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"metadata\",\n\t\treference: metadata,\n\t\tmetadata: metadata_\n\t};\n}\n\n//#endregion\n//#region src/actions/mimeType/mimeType.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mimeType(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"mime_type\",\n\t\treference: mimeType,\n\t\tasync: false,\n\t\texpects: /* @__PURE__ */ _joinExpects(requirement.map((option) => `\"${option}\"`), \"|\"),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.includes(dataset.value.type)) _addIssue(this, \"MIME type\", dataset, config$1, { received: `\"${dataset.value.type}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minBytes/minBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_bytes\",\n\t\treference: minBytes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 < this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minEntries/minEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_entries\",\n\t\treference: minEntries,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count < this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minGraphemes/minGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_graphemes\",\n\t\treference: minGraphemes,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minLength/minLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_length\",\n\t\treference: minLength,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length < this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minSize/minSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_size\",\n\t\treference: minSize,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size < this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minValue/minValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_value\",\n\t\treference: minValue,\n\t\tasync: false,\n\t\texpects: `>=${requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(dataset.value >= this.requirement)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/minWords/minWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction minWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"min_words\",\n\t\treference: minWords,\n\t\tasync: false,\n\t\texpects: `>=${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count < this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/multipleOf/multipleOf.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction multipleOf(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"multiple_of\",\n\t\treference: multipleOf,\n\t\tasync: false,\n\t\texpects: `%${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value % this.requirement != 0) _addIssue(this, \"multiple\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nanoid/nanoid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nanoid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"nanoid\",\n\t\treference: nanoid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: NANO_ID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"Nano ID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/nonEmpty/nonEmpty.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonEmpty(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"non_empty\",\n\t\treference: nonEmpty,\n\t\tasync: false,\n\t\texpects: \"!0\",\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === 0) _addIssue(this, \"length\", dataset, config$1, { received: \"0\" });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/normalize/normalize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction normalize(form) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"normalize\",\n\t\treference: normalize,\n\t\tasync: false,\n\t\tform,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.normalize(this.form);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notBytes/notBytes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notBytes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_bytes\",\n\t\treference: notBytes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst length$1 = /* @__PURE__ */ _getByteCount(dataset.value);\n\t\t\t\tif (length$1 === this.requirement) _addIssue(this, \"bytes\", dataset, config$1, { received: `${length$1}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notEntries/notEntries.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notEntries(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_entries\",\n\t\treference: notEntries,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!dataset.typed) return dataset;\n\t\t\tconst count = Object.keys(dataset.value).length;\n\t\t\tif (dataset.typed && count === this.requirement) _addIssue(this, \"entries\", dataset, config$1, { received: `${count}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notGraphemes/notGraphemes.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notGraphemes(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_graphemes\",\n\t\treference: notGraphemes,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getGraphemeCount(dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"graphemes\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notLength/notLength.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notLength(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_length\",\n\t\treference: notLength,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.length === this.requirement) _addIssue(this, \"length\", dataset, config$1, { received: `${dataset.value.length}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notSize/notSize.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notSize(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_size\",\n\t\treference: notSize,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size === this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValue/notValue.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValue(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_value\",\n\t\treference: notValue,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${/* @__PURE__ */ _stringify(requirement)}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notValues/notValues.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notValues(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_values\",\n\t\treference: notValues,\n\t\tasync: false,\n\t\texpects: `!${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/notWords/notWords.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction notWords(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"not_words\",\n\t\treference: notWords,\n\t\tasync: false,\n\t\texpects: `!${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count === this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/octal/octal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction octal(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"octal\",\n\t\treference: octal,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: OCTAL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"octal\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/parseJson/parseJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parseJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"parse_json\",\n\t\treference: parseJson,\n\t\tconfig: config$1,\n\t\tmessage: message$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tdataset.value = JSON.parse(dataset.value, this.config?.reviver);\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\n/**\n* Checks if a dataset is partially typed.\n*\n* @param dataset The dataset to check.\n* @param paths The paths to check.\n*\n* @returns Whether it is partially typed.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _isPartiallyTyped(dataset, paths) {\n\tif (dataset.issues) for (const path of paths) for (const issue of dataset.issues) {\n\t\tlet typed = false;\n\t\tconst bound = Math.min(path.length, issue.path?.length ?? 0);\n\t\tfor (let index = 0; index < bound; index++) if (path[index] !== issue.path[index].key && (path[index] !== \"$\" || issue.path[index].type !== \"array\")) {\n\t\t\ttyped = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (!typed) return false;\n\t}\n\treturn true;\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheck.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheck(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/partialCheck/partialCheckAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialCheckAsync(paths, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"partial_check\",\n\t\treference: partialCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tpaths,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif ((dataset.typed || /* @__PURE__ */ _isPartiallyTyped(dataset, paths)) && !await this.requirement(dataset.value)) _addIssue(this, \"input\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheck.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheck(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheck,\n\t\tasync: false,\n\t\texpects: null,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\taction({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawCheck/rawCheckAsync.ts\n/**\n* Creates a raw check validation action.\n*\n* @param action The validation action.\n*\n* @returns A raw check action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawCheckAsync(action) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"raw_check\",\n\t\treference: rawCheckAsync,\n\t\tasync: true,\n\t\texpects: null,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tawait action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info)\n\t\t\t});\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransform.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransform(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransform,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst output = action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rawTransform/rawTransformAsync.ts\n/**\n* Creates a raw transformation action.\n*\n* @param action The transformation action.\n*\n* @returns A raw transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction rawTransformAsync(action) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"raw_transform\",\n\t\treference: rawTransformAsync,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst output = await action({\n\t\t\t\tdataset,\n\t\t\t\tconfig: config$1,\n\t\t\t\taddIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config$1, info),\n\t\t\t\tNEVER: null\n\t\t\t});\n\t\t\tif (dataset.issues) dataset.typed = false;\n\t\t\telse dataset.value = output;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/readonly/readonly.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction readonly() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"readonly\",\n\t\treference: readonly,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/reduceItems/reduceItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction reduceItems(operation, initial) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"reduce_items\",\n\t\treference: reduceItems,\n\t\tasync: false,\n\t\toperation,\n\t\tinitial,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.reduce(this.operation, this.initial);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/regex/regex.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction regex(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"regex\",\n\t\treference: regex,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"format\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returns.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returns(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returns,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = (...args_) => {\n\t\t\t\tconst returnsDataset = this.schema[\"~run\"]({ value: func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/returns/returnsAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction returnsAsync(schema) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"returns\",\n\t\treference: returnsAsync,\n\t\tasync: false,\n\t\tschema,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst func = dataset.value;\n\t\t\tdataset.value = async (...args_) => {\n\t\t\t\tconst returnsDataset = await this.schema[\"~run\"]({ value: await func(...args_) }, config$1);\n\t\t\t\tif (returnsDataset.issues) throw new ValiError(returnsDataset.issues);\n\t\t\t\treturn returnsDataset.value;\n\t\t\t};\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/rfcEmail/rfcEmail.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction rfcEmail(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"rfc_email\",\n\t\treference: rfcEmail,\n\t\texpects: null,\n\t\tasync: false,\n\t\trequirement: RFC_EMAIL_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"email\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/safeInteger/safeInteger.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeInteger(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"safe_integer\",\n\t\treference: safeInteger,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: Number.isSafeInteger,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"safe integer\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/size/size.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction size(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"size\",\n\t\treference: size,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && dataset.value.size !== this.requirement) _addIssue(this, \"size\", dataset, config$1, { received: `${dataset.value.size}` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/slug/slug.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction slug(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"slug\",\n\t\treference: slug,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: SLUG_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"slug\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/someItem/someItem.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction someItem(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"some_item\",\n\t\treference: someItem,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.some(this.requirement)) _addIssue(this, \"item\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/sortItems/sortItems.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction sortItems(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"sort_items\",\n\t\treference: sortItems,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.sort(this.operation);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/startsWith/startsWith.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction startsWith(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"starts_with\",\n\t\treference: startsWith,\n\t\tasync: false,\n\t\texpects: `\"${requirement}\"`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !dataset.value.startsWith(this.requirement)) _addIssue(this, \"start\", dataset, config$1, { received: `\"${dataset.value.slice(0, this.requirement.length)}\"` });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/stringifyJson/stringifyJson.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction stringifyJson(config$1, message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"stringify_json\",\n\t\treference: stringifyJson,\n\t\tmessage: message$1,\n\t\tconfig: config$1,\n\t\tasync: false,\n\t\t\"~run\"(dataset, config$2) {\n\t\t\ttry {\n\t\t\t\tconst output = JSON.stringify(dataset.value, this.config?.replacer, this.config?.space);\n\t\t\t\tif (output === void 0) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t\tdataset.value = output;\n\t\t\t} catch (error) {\n\t\t\t\tif (error instanceof Error) {\n\t\t\t\t\t_addIssue(this, \"JSON\", dataset, config$2, { received: `\"${error.message}\"` });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t} else throw error;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/title/title.ts\n/**\n* Creates a title metadata action.\n*\n* @param title_ The title text.\n*\n* @returns A title action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction title(title_) {\n\treturn {\n\t\tkind: \"metadata\",\n\t\ttype: \"title\",\n\t\treference: title,\n\t\ttitle: title_\n\t};\n}\n\n//#endregion\n//#region src/actions/toBigint/toBigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBigint(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_bigint\",\n\t\treference: toBigint,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = BigInt(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"bigint\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toBoolean/toBoolean.ts\n/**\n* Creates a to boolean transformation action.\n*\n* @returns A to boolean action.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toBoolean() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_boolean\",\n\t\treference: toBoolean,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = Boolean(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toDate/toDate.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toDate(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_date\",\n\t\treference: toDate,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = new Date(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"date\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"date\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toLowerCase/toLowerCase.ts\n/**\n* Creates a to lower case transformation action.\n*\n* @returns A to lower case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toLowerCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_lower_case\",\n\t\treference: toLowerCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toLowerCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMaxValue/toMaxValue.ts\n/**\n* Creates a to max value transformation action.\n*\n* @param requirement The maximum value.\n*\n* @returns A to max value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMaxValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_max_value\",\n\t\treference: toMaxValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toMinValue/toMinValue.ts\n/**\n* Creates a to min value transformation action.\n*\n* @param requirement The minimum value.\n*\n* @returns A to min value action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toMinValue(requirement) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_min_value\",\n\t\treference: toMinValue,\n\t\tasync: false,\n\t\trequirement,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toNumber/toNumber.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toNumber(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_number\",\n\t\treference: toNumber,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = Number(dataset.value);\n\t\t\t\tif (isNaN(dataset.value)) {\n\t\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"number\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toString/toString.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction toString(message$1) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_string\",\n\t\treference: toString,\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\ttry {\n\t\t\t\tdataset.value = String(dataset.value);\n\t\t\t} catch {\n\t\t\t\t_addIssue(this, \"string\", dataset, config$1);\n\t\t\t\tdataset.typed = false;\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/toUpperCase/toUpperCase.ts\n/**\n* Creates a to upper case transformation action.\n*\n* @returns A to upper case action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction toUpperCase() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"to_upper_case\",\n\t\treference: toUpperCase,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.toUpperCase();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transform.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transform(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transform,\n\t\tasync: false,\n\t\toperation,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/transform/transformAsync.ts\n/**\n* Creates a custom transformation action.\n*\n* @param operation The transformation operation.\n*\n* @returns A transform action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction transformAsync(operation) {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"transform\",\n\t\treference: transformAsync,\n\t\tasync: true,\n\t\toperation,\n\t\tasync \"~run\"(dataset) {\n\t\t\tdataset.value = await this.operation(dataset.value);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trim/trim.ts\n/**\n* Creates a trim transformation action.\n*\n* @returns A trim action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trim() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim\",\n\t\treference: trim,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trim();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimEnd/trimEnd.ts\n/**\n* Creates a trim end transformation action.\n*\n* @returns A trim end action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimEnd() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_end\",\n\t\treference: trimEnd,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimEnd();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/trimStart/trimStart.ts\n/**\n* Creates a trim start transformation action.\n*\n* @returns A trim start action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction trimStart() {\n\treturn {\n\t\tkind: \"transformation\",\n\t\ttype: \"trim_start\",\n\t\treference: trimStart,\n\t\tasync: false,\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.value = dataset.value.trimStart();\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/ulid/ulid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction ulid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"ulid\",\n\t\treference: ulid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: ULID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"ULID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/url/url.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction url(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"url\",\n\t\treference: url,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement(input) {\n\t\t\ttry {\n\t\t\t\tnew URL(input);\n\t\t\t\treturn true;\n\t\t\t} catch {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement(dataset.value)) _addIssue(this, \"URL\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/uuid/uuid.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction uuid(message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"uuid\",\n\t\treference: uuid,\n\t\tasync: false,\n\t\texpects: null,\n\t\trequirement: UUID_REGEX,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.test(dataset.value)) _addIssue(this, \"UUID\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/value/value.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction value(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"value\",\n\t\treference: value,\n\t\tasync: false,\n\t\texpects: requirement instanceof Date ? requirement.toJSON() : /* @__PURE__ */ _stringify(requirement),\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/values/values.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction values(requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"values\",\n\t\treference: values,\n\t\tasync: false,\n\t\texpects: `${/* @__PURE__ */ _joinExpects(requirement.map((value$1) => value$1 instanceof Date ? value$1.toJSON() : /* @__PURE__ */ _stringify(value$1)), \"|\")}`,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed && !this.requirement.some((value$1) => value$1 <= dataset.value && value$1 >= dataset.value)) _addIssue(this, \"value\", dataset, config$1, { received: dataset.value instanceof Date ? dataset.value.toJSON() : /* @__PURE__ */ _stringify(dataset.value) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/actions/words/words.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction words(locales, requirement, message$1) {\n\treturn {\n\t\tkind: \"validation\",\n\t\ttype: \"words\",\n\t\treference: words,\n\t\tasync: false,\n\t\texpects: `${requirement}`,\n\t\tlocales,\n\t\trequirement,\n\t\tmessage: message$1,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.typed) {\n\t\t\t\tconst count = /* @__PURE__ */ _getWordCount(this.locales, dataset.value);\n\t\t\t\tif (count !== this.requirement) _addIssue(this, \"words\", dataset, config$1, { received: `${count}` });\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/assert/assert.ts\n/**\n* Checks if the input matches the schema. As this is an assertion function, it\n* can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*/\nfunction assert(schema, input) {\n\tconst issues = schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n\tif (issues) throw new ValiError(issues);\n}\n\n//#endregion\n//#region src/methods/config/config.ts\n/**\n* Changes the local configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param config The parse configuration.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction config(schema, config$1) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config_) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config_,\n\t\t\t\t...config$1\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getFallback/getFallback.ts\n/**\n* Returns the fallback value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The output dataset if available.\n* @param config The config if available.\n*\n* @returns The fallback value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallback(schema, dataset, config$1) {\n\treturn typeof schema.fallback === \"function\" ? schema.fallback(dataset, config$1) : schema.fallback;\n}\n\n//#endregion\n//#region src/methods/fallback/fallback.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallback(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/fallback/fallbackAsync.ts\n/**\n* Returns a fallback value as output if the input does not match the schema.\n*\n* @param schema The schema to catch.\n* @param fallback The fallback value.\n*\n* @returns The passed schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction fallbackAsync(schema, fallback$1) {\n\treturn {\n\t\t...schema,\n\t\tfallback: fallback$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst outputDataset = await schema[\"~run\"](dataset, config$1);\n\t\t\treturn outputDataset.issues ? {\n\t\t\t\ttyped: true,\n\t\t\t\tvalue: await /* @__PURE__ */ getFallback(this, outputDataset, config$1)\n\t\t\t} : outputDataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/flatten/flatten.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction flatten(issues) {\n\tconst flatErrors = {};\n\tfor (const issue of issues) if (issue.path) {\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) {\n\t\t\tif (!flatErrors.nested) flatErrors.nested = {};\n\t\t\tif (flatErrors.nested[dotPath]) flatErrors.nested[dotPath].push(issue.message);\n\t\t\telse flatErrors.nested[dotPath] = [issue.message];\n\t\t} else if (flatErrors.other) flatErrors.other.push(issue.message);\n\t\telse flatErrors.other = [issue.message];\n\t} else if (flatErrors.root) flatErrors.root.push(issue.message);\n\telse flatErrors.root = [issue.message];\n\treturn flatErrors;\n}\n\n//#endregion\n//#region src/methods/forward/forward.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forward(action, path) {\n\treturn {\n\t\t...action,\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/forward/forwardAsync.ts\n/**\n* Forwards the issues of the passed validation action.\n*\n* @param action The validation action.\n* @param path The path to forward the issues to.\n*\n* @returns The modified action.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction forwardAsync(action, path) {\n\treturn {\n\t\t...action,\n\t\tasync: true,\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst prevIssues = dataset.issues && [...dataset.issues];\n\t\t\tdataset = await action[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.issues) {\n\t\t\t\tfor (const issue of dataset.issues) if (!prevIssues?.includes(issue)) {\n\t\t\t\t\tlet pathInput = dataset.value;\n\t\t\t\t\tfor (const key of path) {\n\t\t\t\t\t\tconst pathValue = pathInput[key];\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"unknown\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput: pathInput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: pathValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (issue.path) issue.path.push(pathItem);\n\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\tif (!pathValue) break;\n\t\t\t\t\t\tpathInput = pathValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/getDefault/getDefault.ts\n/**\n* Returns the default value of the schema.\n*\n* @param schema The schema to get it from.\n* @param dataset The input dataset if available.\n* @param config The config if available.\n*\n* @returns The default value.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefault(schema, dataset, config$1) {\n\treturn typeof schema.default === \"function\" ? schema.default(dataset, config$1) : schema.default;\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaults.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDefaults(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getDefaults(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getDefaults);\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDefaults/getDefaultsAsync.ts\n/**\n* Returns the default values of the schema.\n*\n* Hint: The difference to `getDefault` is that for object and tuple schemas\n* this function recursively returns the default values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The default values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getDefaultsAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getDefaultsAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getDefaultsAsync));\n\treturn /* @__PURE__ */ getDefault(schema);\n}\n\n//#endregion\n//#region src/methods/getDescription/getDescription.ts\n/**\n* Returns the description of the schema.\n*\n* If multiple descriptions are defined, the last one of the highest level is\n* returned. If no description is defined, `undefined` is returned.\n*\n* @param schema The schema to get the description from.\n*\n* @returns The description, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getDescription(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"description\");\n}\n\n//#endregion\n//#region src/methods/getExamples/getExamples.ts\n/**\n* Returns the examples of a schema.\n*\n* If multiple examples are defined, it concatenates them using depth-first\n* search. If no examples are defined, an empty array is returned.\n*\n* @param schema The schema to get the examples from.\n*\n* @returns The examples, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getExamples(schema) {\n\tconst examples$1 = [];\n\tfunction depthFirstCollect(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstCollect(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"examples\") examples$1.push(...item.examples);\n\t\t}\n\t}\n\tdepthFirstCollect(schema);\n\treturn examples$1;\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacks.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getFallbacks(schema) {\n\tif (\"entries\" in schema) {\n\t\tconst object$1 = {};\n\t\tfor (const key in schema.entries) object$1[key] = /* @__PURE__ */ getFallbacks(schema.entries[key]);\n\t\treturn object$1;\n\t}\n\tif (\"items\" in schema) return schema.items.map(getFallbacks);\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getFallbacks/getFallbacksAsync.ts\n/**\n* Returns the fallback values of the schema.\n*\n* Hint: The difference to `getFallback` is that for object and tuple schemas\n* this function recursively returns the fallback values of the subschemas\n* instead of `undefined`.\n*\n* @param schema The schema to get them from.\n*\n* @returns The fallback values.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function getFallbacksAsync(schema) {\n\tif (\"entries\" in schema) return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value$1]) => [key, await /* @__PURE__ */ getFallbacksAsync(value$1)])));\n\tif (\"items\" in schema) return Promise.all(schema.items.map(getFallbacksAsync));\n\treturn /* @__PURE__ */ getFallback(schema);\n}\n\n//#endregion\n//#region src/methods/getMetadata/getMetadata.ts\n/**\n* Returns the metadata of a schema.\n*\n* If multiple metadata are defined, it shallowly merges them using depth-first\n* search. If no metadata is defined, an empty object is returned.\n*\n* @param schema Schema to get the metadata from.\n*\n* @returns The metadata, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getMetadata(schema) {\n\tconst result = {};\n\tfunction depthFirstMerge(schema$1) {\n\t\tif (\"pipe\" in schema$1) {\n\t\t\tfor (const item of schema$1.pipe) if (item.kind === \"schema\" && \"pipe\" in item) depthFirstMerge(item);\n\t\t\telse if (item.kind === \"metadata\" && item.type === \"metadata\") Object.assign(result, item.metadata);\n\t\t}\n\t}\n\tdepthFirstMerge(schema);\n\treturn result;\n}\n\n//#endregion\n//#region src/methods/getTitle/getTitle.ts\n/**\n* Returns the title of the schema.\n*\n* If multiple titles are defined, the last one of the highest level is\n* returned. If no title is defined, `undefined` is returned.\n*\n* @param schema The schema to get the title from.\n*\n* @returns The title, if any.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction getTitle(schema) {\n\treturn /* @__PURE__ */ _getLastMetadata(schema, \"title\");\n}\n\n//#endregion\n//#region src/methods/is/is.ts\n/**\n* Checks if the input matches the schema. By using a type predicate, this\n* function can be used as a type guard.\n*\n* @param schema The schema to be used.\n* @param input The input to be tested.\n*\n* @returns Whether the input matches the schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction is(schema, input) {\n\treturn !schema[\"~run\"]({ value: input }, { abortEarly: true }).issues;\n}\n\n//#endregion\n//#region src/schemas/any/any.ts\n/**\n* Creates an any schema.\n*\n* Hint: This schema function exists only for completeness and is not\n* recommended in practice. Instead, `unknown` should be used to accept\n* unknown data.\n*\n* @returns An any schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction any() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"any\",\n\t\treference: any,\n\t\texpects: \"any\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/array.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction array(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: array,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.item[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/array/arrayAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction arrayAsync(item, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"array\",\n\t\treference: arrayAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titem,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(input.map((value$1) => this.item[\"~run\"]({ value: value$1 }, config$1)));\n\t\t\t\tfor (let key = 0; key < itemDatasets.length; key++) {\n\t\t\t\t\tconst itemDataset = itemDatasets[key];\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/bigint/bigint.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction bigint(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"bigint\",\n\t\treference: bigint,\n\t\texpects: \"bigint\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"bigint\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/blob/blob.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction blob(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"blob\",\n\t\treference: blob,\n\t\texpects: \"Blob\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Blob) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/boolean/boolean.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction boolean(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"boolean\",\n\t\treference: boolean,\n\t\texpects: \"boolean\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"boolean\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/custom.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction custom(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: custom,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/custom/customAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction customAsync(check$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"custom\",\n\t\treference: customAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tcheck: check$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (await this.check(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/date/date.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction date(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"date\",\n\t\treference: date,\n\t\texpects: \"Date\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Date) if (!isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { received: \"\\\"Invalid Date\\\"\" });\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/enum/enum.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction enum_(enum__, message$1) {\n\tconst options = [];\n\tfor (const key in enum__) if (`${+key}` !== key || typeof enum__[key] !== \"string\" || !Object.is(enum__[enum__[key]], +key)) options.push(enum__[key]);\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"enum\",\n\t\treference: enum_,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\tenum: enum__,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptional,\n\t\texpects: wrapped.expects,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/exactOptional/exactOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction exactOptionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"exact_optional\",\n\t\treference: exactOptionalAsync,\n\t\texpects: wrapped.expects,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/file/file.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction file(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"file\",\n\t\treference: file,\n\t\texpects: \"File\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof File) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/function/function.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction function_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"function\",\n\t\treference: function_,\n\t\texpects: \"Function\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"function\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/instance/instance.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction instance(class_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"instance\",\n\t\treference: instance,\n\t\texpects: class_.name,\n\t\tasync: false,\n\t\tclass: class_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof this.class) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/utils/_merge/_merge.ts\n/**\n* Merges two values into one single output.\n*\n* @param value1 First value.\n* @param value2 Second value.\n*\n* @returns The merge dataset.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _merge(value1, value2) {\n\tif (typeof value1 === typeof value2) {\n\t\tif (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) return { value: value1 };\n\t\tif (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n\t\t\tfor (const key in value2) if (key in value1) {\n\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[key], value2[key]);\n\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\tvalue1[key] = dataset.value;\n\t\t\t} else value1[key] = value2[key];\n\t\t\treturn { value: value1 };\n\t\t}\n\t\tif (Array.isArray(value1) && Array.isArray(value2)) {\n\t\t\tif (value1.length === value2.length) {\n\t\t\t\tfor (let index = 0; index < value1.length; index++) {\n\t\t\t\t\tconst dataset = /* @__PURE__ */ _merge(value1[index], value2[index]);\n\t\t\t\t\tif (dataset.issue) return dataset;\n\t\t\t\t\tvalue1[index] = dataset.value;\n\t\t\t\t}\n\t\t\t\treturn { value: value1 };\n\t\t\t}\n\t\t}\n\t}\n\treturn { issue: true };\n}\n\n//#endregion\n//#region src/schemas/intersect/intersect.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersect(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersect,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tfor (const schema of this.options) {\n\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/intersect/intersectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction intersectAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"intersect\",\n\t\treference: intersectAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"&\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (this.options.length) {\n\t\t\t\tconst input = dataset.value;\n\t\t\t\tlet outputs;\n\t\t\t\tdataset.typed = true;\n\t\t\t\tconst optionDatasets = await Promise.all(this.options.map((schema) => schema[\"~run\"]({ value: input }, config$1)));\n\t\t\t\tfor (const optionDataset of optionDatasets) {\n\t\t\t\t\tif (optionDataset.issues) {\n\t\t\t\t\t\tif (dataset.issues) dataset.issues.push(...optionDataset.issues);\n\t\t\t\t\t\telse dataset.issues = optionDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!optionDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (dataset.typed) if (outputs) outputs.push(optionDataset.value);\n\t\t\t\t\telse outputs = [optionDataset.value];\n\t\t\t\t}\n\t\t\t\tif (dataset.typed) {\n\t\t\t\t\tdataset.value = outputs[0];\n\t\t\t\t\tfor (let index = 1; index < outputs.length; index++) {\n\t\t\t\t\t\tconst mergeDataset = /* @__PURE__ */ _merge(dataset.value, outputs[index]);\n\t\t\t\t\t\tif (mergeDataset.issue) {\n\t\t\t\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { received: \"unknown\" });\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataset.value = mergeDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazy.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazy(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazy,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn this.getter(dataset.value)[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/lazy/lazyAsync.ts\n/**\n* Creates a lazy schema.\n*\n* @param getter The schema getter.\n*\n* @returns A lazy schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction lazyAsync(getter) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"lazy\",\n\t\treference: lazyAsync,\n\t\texpects: \"unknown\",\n\t\tasync: true,\n\t\tgetter,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\treturn (await this.getter(dataset.value))[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/literal/literal.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction literal(literal_, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"literal\",\n\t\treference: literal,\n\t\texpects: /* @__PURE__ */ _stringify(literal_),\n\t\tasync: false,\n\t\tliteral: literal_,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === this.literal) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseObject/looseObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_object\",\n\t\treference: looseObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) dataset.value[key] = input[key];\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/looseTuple/looseTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction looseTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"loose_tuple\",\n\t\treference: looseTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) dataset.value.push(input[key]);\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/map.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction map(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: map,\n\t\texpects: \"Map\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tfor (const [inputKey, inputValue] of input) {\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: inputKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/map/mapAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction mapAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"map\",\n\t\treference: mapAsync,\n\t\texpects: \"Map\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Map) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Map();\n\t\t\t\tconst datasets = await Promise.all([...input].map(([inputKey, inputValue]) => Promise.all([\n\t\t\t\t\tinputKey,\n\t\t\t\t\tinputValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: inputKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: inputValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [inputKey, inputValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"map\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: inputKey,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.set(keyDataset.value, valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nan/nan.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nan(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nan\",\n\t\treference: nan,\n\t\texpects: \"NaN\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (Number.isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/never/never.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction never(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"never\",\n\t\treference: never,\n\t\texpects: \"never\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\t_addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullable(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullable,\n\t\texpects: \"!null\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullable/nonNullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullableAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullable\",\n\t\treference: nonNullableAsync,\n\t\texpects: \"!null\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== null) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullish(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullish,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonNullish/nonNullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonNullishAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_nullish\",\n\t\treference: nonNullishAsync,\n\t\texpects: \"(!null & !undefined)\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (!(dataset.value === null || dataset.value === void 0)) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === null || dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptional(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptional,\n\t\texpects: \"!undefined\",\n\t\tasync: false,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nonOptional/nonOptionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nonOptionalAsync(wrapped, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"non_optional\",\n\t\treference: nonOptionalAsync,\n\t\texpects: \"!undefined\",\n\t\tasync: true,\n\t\twrapped,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value !== void 0) dataset = await this.wrapped[\"~run\"](dataset, config$1);\n\t\t\tif (dataset.value === void 0) _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/null/null.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction null_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"null\",\n\t\treference: null_,\n\t\texpects: \"null\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullable,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullable/nullableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullable\",\n\t\treference: nullableAsync,\n\t\texpects: `(${wrapped.expects} | null)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullish.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullish(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullish,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/nullish/nullishAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction nullishAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"nullish\",\n\t\treference: nullishAsync,\n\t\texpects: `(${wrapped.expects} | null | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === null || dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/number/number.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction number(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"number\",\n\t\treference: number,\n\t\texpects: \"number\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"number\" && !isNaN(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/object.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction object(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: object,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/object/objectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object\",\n\t\treference: objectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRest(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRest,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (/* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)) {\n\t\t\t\t\t\tconst valueDataset = this.rest[\"~run\"]({ value: input[key] }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/objectWithRest/objectWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction objectWithRestAsync(entries$1, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"object_with_rest\",\n\t\treference: objectWithRestAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(Object.entries(input).filter(([key]) => /* @__PURE__ */ _isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value$1]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue$1,\n\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t]))]);\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of normalDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, valueDataset] of restDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optional.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optional(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optional,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/optional/optionalAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction optionalAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"optional\",\n\t\treference: optionalAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/picklist/picklist.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction picklist(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"picklist\",\n\t\treference: picklist,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map(_stringify), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (this.options.includes(dataset.value)) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/promise/promise.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction promise(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"promise\",\n\t\treference: promise,\n\t\texpects: \"Promise\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value instanceof Promise) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/record.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction record(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: record,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const entryKey in input) if (/* @__PURE__ */ _isValidObjectKey(input, entryKey)) {\n\t\t\t\t\tconst entryValue = input[entryKey];\n\t\t\t\t\tconst keyDataset = this.key[\"~run\"]({ value: entryKey }, config$1);\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: entryValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/record/recordAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction recordAsync(key, value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"record\",\n\t\treference: recordAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst datasets = await Promise.all(Object.entries(input).filter(([key$1]) => /* @__PURE__ */ _isValidObjectKey(input, key$1)).map(([entryKey, entryValue]) => Promise.all([\n\t\t\t\t\tentryKey,\n\t\t\t\t\tentryValue,\n\t\t\t\t\tthis.key[\"~run\"]({ value: entryKey }, config$1),\n\t\t\t\t\tthis.value[\"~run\"]({ value: entryValue }, config$1)\n\t\t\t\t])));\n\t\t\t\tfor (const [entryKey, entryValue, keyDataset, valueDataset] of datasets) {\n\t\t\t\t\tif (keyDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of keyDataset.issues) {\n\t\t\t\t\t\t\tissue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = keyDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: entryKey,\n\t\t\t\t\t\t\tvalue: entryValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!keyDataset.typed || !valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tif (keyDataset.typed) dataset.value[keyDataset.value] = valueDataset.value;\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/set.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction set(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: set,\n\t\texpects: \"Set\",\n\t\tasync: false,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tfor (const inputValue of input) {\n\t\t\t\t\tconst valueDataset = this.value[\"~run\"]({ value: inputValue }, config$1);\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/set/setAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction setAsync(value$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"set\",\n\t\treference: setAsync,\n\t\texpects: \"Set\",\n\t\tasync: true,\n\t\tvalue: value$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input instanceof Set) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = /* @__PURE__ */ new Set();\n\t\t\t\tconst valueDatasets = await Promise.all([...input].map(async (inputValue) => [inputValue, await this.value[\"~run\"]({ value: inputValue }, config$1)]));\n\t\t\t\tfor (const [inputValue, valueDataset] of valueDatasets) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"set\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey: null,\n\t\t\t\t\t\t\tvalue: inputValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.add(valueDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObject.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObject(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObject,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tfor (const key in this.entries) {\n\t\t\t\t\tconst valueSchema = this.entries[key];\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\tconst valueDataset = valueSchema[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictObject/strictObjectAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictObjectAsync(entries$1, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_object\",\n\t\treference: strictObjectAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tentries: entries$1,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = {};\n\t\t\t\tconst valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, valueSchema]) => {\n\t\t\t\t\tif (key in input || (valueSchema.type === \"exact_optional\" || valueSchema.type === \"optional\" || valueSchema.type === \"nullish\") && valueSchema.default !== void 0) {\n\t\t\t\t\t\tconst value$1 = key in input ? input[key] : await /* @__PURE__ */ getDefault(valueSchema);\n\t\t\t\t\t\treturn [\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\t\tawait valueSchema[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tinput[key],\n\t\t\t\t\t\tvalueSchema,\n\t\t\t\t\t\tnull\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, valueSchema, valueDataset] of valueDatasets) if (valueDataset) {\n\t\t\t\t\tif (valueDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of valueDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = valueDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!valueDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value[key] = valueDataset.value;\n\t\t\t\t} else if (valueSchema.fallback !== void 0) dataset.value[key] = await /* @__PURE__ */ getFallback(valueSchema);\n\t\t\t\telse if (valueSchema.type !== \"exact_optional\" && valueSchema.type !== \"optional\" && valueSchema.type !== \"nullish\") {\n\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\texpected: `\"${key}\"`,\n\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t}]\n\t\t\t\t\t});\n\t\t\t\t\tif (config$1.abortEarly) break;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) {\n\t\t\t\t\tfor (const key in input) if (!(key in this.entries)) {\n\t\t\t\t\t\t_addIssue(this, \"key\", dataset, config$1, {\n\t\t\t\t\t\t\tinput: key,\n\t\t\t\t\t\t\texpected: \"never\",\n\t\t\t\t\t\t\tpath: [{\n\t\t\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\t\t\torigin: \"key\",\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tvalue: input[key]\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/strictTuple/strictTupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction strictTupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"strict_tuple\",\n\t\treference: strictTupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!(dataset.issues && config$1.abortEarly) && this.items.length < input.length) _addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[this.items.length],\n\t\t\t\t\texpected: \"never\",\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: this.items.length,\n\t\t\t\t\t\tvalue: input[this.items.length]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/string/string.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction string(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"string\",\n\t\treference: string,\n\t\texpects: \"string\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"string\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/symbol/symbol.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction symbol(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"symbol\",\n\t\treference: symbol,\n\t\texpects: \"symbol\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (typeof dataset.value === \"symbol\") dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tuple.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tuple(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tuple,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tuple/tupleAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleAsync(items, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple\",\n\t\treference: tupleAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst itemDatasets = await Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}));\n\t\t\t\tfor (const [key, value$1, itemDataset] of itemDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRest.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRest(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRest,\n\t\texpects: \"Array\",\n\t\tasync: false,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tfor (let key = 0; key < this.items.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.items[key][\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (let key = this.items.length; key < input.length; key++) {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\tconst itemDataset = this.rest[\"~run\"]({ value: value$1 }, config$1);\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/tupleWithRest/tupleWithRestAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction tupleWithRestAsync(items, rest, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"tuple_with_rest\",\n\t\treference: tupleWithRestAsync,\n\t\texpects: \"Array\",\n\t\tasync: true,\n\t\titems,\n\t\trest,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (Array.isArray(input)) {\n\t\t\t\tdataset.typed = true;\n\t\t\t\tdataset.value = [];\n\t\t\t\tconst [normalDatasets, restDatasets] = await Promise.all([Promise.all(this.items.map(async (item, key) => {\n\t\t\t\t\tconst value$1 = input[key];\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait item[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t})), Promise.all(input.slice(this.items.length).map(async (value$1, key) => {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tkey + this.items.length,\n\t\t\t\t\t\tvalue$1,\n\t\t\t\t\t\tawait this.rest[\"~run\"]({ value: value$1 }, config$1)\n\t\t\t\t\t];\n\t\t\t\t}))]);\n\t\t\t\tfor (const [key, value$1, itemDataset] of normalDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly) for (const [key, value$1, itemDataset] of restDatasets) {\n\t\t\t\t\tif (itemDataset.issues) {\n\t\t\t\t\t\tconst pathItem = {\n\t\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tvalue: value$1\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfor (const issue of itemDataset.issues) {\n\t\t\t\t\t\t\tif (issue.path) issue.path.unshift(pathItem);\n\t\t\t\t\t\t\telse issue.path = [pathItem];\n\t\t\t\t\t\t\tdataset.issues?.push(issue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dataset.issues) dataset.issues = itemDataset.issues;\n\t\t\t\t\t\tif (config$1.abortEarly) {\n\t\t\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!itemDataset.typed) dataset.typed = false;\n\t\t\t\t\tdataset.value.push(itemDataset.value);\n\t\t\t\t}\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefined/undefined.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefined_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefined\",\n\t\treference: undefined_,\n\t\texpects: \"undefined\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedable.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedable(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedable,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: false,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/undefinedable/undefinedableAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction undefinedableAsync(wrapped, default_) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"undefinedable\",\n\t\treference: undefinedableAsync,\n\t\texpects: `(${wrapped.expects} | undefined)`,\n\t\tasync: true,\n\t\twrapped,\n\t\tdefault: default_,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) {\n\t\t\t\tif (this.default !== void 0) dataset.value = await /* @__PURE__ */ getDefault(this, dataset, config$1);\n\t\t\t\tif (dataset.value === void 0) {\n\t\t\t\t\tdataset.typed = true;\n\t\t\t\t\treturn dataset;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.wrapped[\"~run\"](dataset, config$1);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/utils/_subIssues/_subIssues.ts\n/**\n* Returns the sub issues of the provided datasets for the union issue.\n*\n* @param datasets The datasets.\n*\n* @returns The sub issues.\n*\n* @internal\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction _subIssues(datasets) {\n\tlet issues;\n\tif (datasets) for (const dataset of datasets) if (issues) issues.push(...dataset.issues);\n\telse issues = dataset.issues;\n\treturn issues;\n}\n\n//#endregion\n//#region src/schemas/union/union.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction union(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: union,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: false,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/union/unionAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction unionAsync(options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"union\",\n\t\treference: unionAsync,\n\t\texpects: /* @__PURE__ */ _joinExpects(options.map((option) => option.expects), \"|\"),\n\t\tasync: true,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tlet validDataset;\n\t\t\tlet typedDatasets;\n\t\t\tlet untypedDatasets;\n\t\t\tfor (const schema of this.options) {\n\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: dataset.value }, config$1);\n\t\t\t\tif (optionDataset.typed) if (optionDataset.issues) if (typedDatasets) typedDatasets.push(optionDataset);\n\t\t\t\telse typedDatasets = [optionDataset];\n\t\t\t\telse {\n\t\t\t\t\tvalidDataset = optionDataset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (untypedDatasets) untypedDatasets.push(optionDataset);\n\t\t\t\telse untypedDatasets = [optionDataset];\n\t\t\t}\n\t\t\tif (validDataset) return validDataset;\n\t\t\tif (typedDatasets) {\n\t\t\t\tif (typedDatasets.length === 1) return typedDatasets[0];\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(typedDatasets) });\n\t\t\t\tdataset.typed = true;\n\t\t\t} else if (untypedDatasets?.length === 1) return untypedDatasets[0];\n\t\t\telse _addIssue(this, \"type\", dataset, config$1, { issues: /* @__PURE__ */ _subIssues(untypedDatasets) });\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/unknown/unknown.ts\n/**\n* Creates a unknown schema.\n*\n* @returns A unknown schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unknown() {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"unknown\",\n\t\treference: unknown,\n\t\texpects: \"unknown\",\n\t\tasync: false,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset) {\n\t\t\tdataset.typed = true;\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variant.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variant(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variant,\n\t\texpects: \"Object\",\n\t\tasync: false,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true }).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tparseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/variant/variantAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction variantAsync(key, options, message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"variant\",\n\t\treference: variantAsync,\n\t\texpects: \"Object\",\n\t\tasync: true,\n\t\tkey,\n\t\toptions,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tconst input = dataset.value;\n\t\t\tif (input && typeof input === \"object\") {\n\t\t\t\tlet outputDataset;\n\t\t\t\tlet maxDiscriminatorPriority = 0;\n\t\t\t\tlet invalidDiscriminatorKey = this.key;\n\t\t\t\tlet expectedDiscriminators = [];\n\t\t\t\tconst parseOptions = async (variant$1, allKeys) => {\n\t\t\t\t\tfor (const schema of variant$1.options) {\n\t\t\t\t\t\tif (schema.type === \"variant\") await parseOptions(schema, new Set(allKeys).add(schema.key));\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet keysAreValid = true;\n\t\t\t\t\t\t\tlet currentPriority = 0;\n\t\t\t\t\t\t\tfor (const currentKey of allKeys) {\n\t\t\t\t\t\t\t\tconst discriminatorSchema = schema.entries[currentKey];\n\t\t\t\t\t\t\t\tif (currentKey in input ? (await discriminatorSchema[\"~run\"]({\n\t\t\t\t\t\t\t\t\ttyped: false,\n\t\t\t\t\t\t\t\t\tvalue: input[currentKey]\n\t\t\t\t\t\t\t\t}, { abortEarly: true })).issues : discriminatorSchema.type !== \"exact_optional\" && discriminatorSchema.type !== \"optional\" && discriminatorSchema.type !== \"nullish\") {\n\t\t\t\t\t\t\t\t\tkeysAreValid = false;\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n\t\t\t\t\t\t\t\t\t\tmaxDiscriminatorPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\tinvalidDiscriminatorKey = currentKey;\n\t\t\t\t\t\t\t\t\t\texpectedDiscriminators = [];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (invalidDiscriminatorKey === currentKey) expectedDiscriminators.push(schema.entries[currentKey].expects);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcurrentPriority++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (keysAreValid) {\n\t\t\t\t\t\t\t\tconst optionDataset = await schema[\"~run\"]({ value: input }, config$1);\n\t\t\t\t\t\t\t\tif (!outputDataset || !outputDataset.typed && optionDataset.typed) outputDataset = optionDataset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (outputDataset && !outputDataset.issues) break;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tawait parseOptions(this, new Set([this.key]));\n\t\t\t\tif (outputDataset) return outputDataset;\n\t\t\t\t_addIssue(this, \"type\", dataset, config$1, {\n\t\t\t\t\tinput: input[invalidDiscriminatorKey],\n\t\t\t\t\texpected: /* @__PURE__ */ _joinExpects(expectedDiscriminators, \"|\"),\n\t\t\t\t\tpath: [{\n\t\t\t\t\t\ttype: \"object\",\n\t\t\t\t\t\torigin: \"value\",\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tkey: invalidDiscriminatorKey,\n\t\t\t\t\t\tvalue: input[invalidDiscriminatorKey]\n\t\t\t\t\t}]\n\t\t\t\t});\n\t\t\t} else _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/schemas/void/void.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction void_(message$1) {\n\treturn {\n\t\tkind: \"schema\",\n\t\ttype: \"void\",\n\t\treference: void_,\n\t\texpects: \"void\",\n\t\tasync: false,\n\t\tmessage: message$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tif (dataset.value === void 0) dataset.typed = true;\n\t\t\telse _addIssue(this, \"type\", dataset, config$1);\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/keyof/keyof.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction keyof(schema, message$1) {\n\treturn /* @__PURE__ */ picklist(Object.keys(schema.entries), message$1);\n}\n\n//#endregion\n//#region src/methods/message/message.ts\n/**\n* Changes the local message configuration of a schema.\n*\n* @param schema The schema to configure.\n* @param message_ The error message.\n*\n* @returns The configured schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction message(schema, message_) {\n\treturn {\n\t\t...schema,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\treturn schema[\"~run\"](dataset, {\n\t\t\t\t...config$1,\n\t\t\t\tmessage: message_\n\t\t\t});\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/omit/omit.ts\n/**\n* Creates a modified copy of an object schema that does not contain the\n* selected entries.\n*\n* @param schema The schema to omit from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction omit(schema, keys) {\n\tconst entries$1 = { ...schema.entries };\n\tfor (const key of keys) delete entries$1[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/parse/parse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nfunction parse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parse/parseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parsed input.\n*/\nasync function parseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\tif (dataset.issues) throw new ValiError(dataset.issues);\n\treturn dataset.value;\n}\n\n//#endregion\n//#region src/methods/parser/parser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parser(schema, config$1) {\n\tconst func = (input) => parse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/parser/parserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction parserAsync(schema, config$1) {\n\tconst func = (input) => parseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/partial/partial.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partial(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optional(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/partial/partialAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction partialAsync(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ optionalAsync(schema.entries[key]) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pick/pick.ts\n/**\n* Creates a modified copy of an object schema that contains only the selected\n* entries.\n*\n* @param schema The schema to pick from.\n* @param keys The selected entries.\n*\n* @returns An object schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction pick(schema, keys) {\n\tconst entries$1 = {};\n\tfor (const key of keys) entries$1[key] = schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipe.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipe(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\t\"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/pipe/pipeAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction pipeAsync(...pipe$1) {\n\treturn {\n\t\t...pipe$1[0],\n\t\tpipe: pipe$1,\n\t\tasync: true,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t},\n\t\tasync \"~run\"(dataset, config$1) {\n\t\t\tfor (const item of pipe$1) if (item.kind !== \"metadata\") {\n\t\t\t\tif (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n\t\t\t\t\tdataset.typed = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dataset.issues || !config$1.abortEarly && !config$1.abortPipeEarly) dataset = await item[\"~run\"](dataset, config$1);\n\t\t\t}\n\t\t\treturn dataset;\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/required.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction required(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptional(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/required/requiredAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction requiredAsync(schema, arg2, arg3) {\n\tconst keys = Array.isArray(arg2) ? arg2 : void 0;\n\tconst message$1 = Array.isArray(arg2) ? arg3 : arg2;\n\tconst entries$1 = {};\n\tfor (const key in schema.entries) entries$1[key] = !keys || keys.includes(key) ? /* @__PURE__ */ nonOptionalAsync(schema.entries[key], message$1) : schema.entries[key];\n\treturn {\n\t\t...schema,\n\t\tentries: entries$1,\n\t\tget \"~standard\"() {\n\t\t\treturn /* @__PURE__ */ _getStandardProps(this);\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParse.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParse(schema, input, config$1) {\n\tconst dataset = schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParse/safeParseAsync.ts\n/**\n* Parses an unknown input based on a schema.\n*\n* @param schema The schema to be used.\n* @param input The input to be parsed.\n* @param config The parse configuration.\n*\n* @returns The parse result.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nasync function safeParseAsync(schema, input, config$1) {\n\tconst dataset = await schema[\"~run\"]({ value: input }, /* @__PURE__ */ getGlobalConfig(config$1));\n\treturn {\n\t\ttyped: dataset.typed,\n\t\tsuccess: !dataset.issues,\n\t\toutput: dataset.value,\n\t\tissues: dataset.issues\n\t};\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParser.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParser(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParse(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/safeParser/safeParserAsync.ts\n/* @__NO_SIDE_EFFECTS__ */\nfunction safeParserAsync(schema, config$1) {\n\tconst func = (input) => /* @__PURE__ */ safeParseAsync(schema, input, config$1);\n\tfunc.schema = schema;\n\tfunc.config = config$1;\n\treturn func;\n}\n\n//#endregion\n//#region src/methods/summarize/summarize.ts\n/**\n* Summarize the error messages of issues in a pretty-printable multi-line string.\n*\n* @param issues The list of issues.\n*\n* @returns A summary of the issues.\n*\n* @beta\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction summarize(issues) {\n\tlet summary = \"\";\n\tfor (const issue of issues) {\n\t\tif (summary) summary += \"\\n\";\n\t\tsummary += ` ${issue.message}`;\n\t\tconst dotPath = /* @__PURE__ */ getDotPath(issue);\n\t\tif (dotPath) summary += `\\n   at ${dotPath}`;\n\t}\n\treturn summary;\n}\n\n//#endregion\n//#region src/methods/unwrap/unwrap.ts\n/**\n* Unwraps the wrapped schema.\n*\n* @param schema The schema to be unwrapped.\n*\n* @returns The unwrapped schema.\n*/\n/* @__NO_SIDE_EFFECTS__ */\nfunction unwrap(schema) {\n\treturn schema.wrapped;\n}\n\n//#endregion\nexport { BASE64_REGEX, BIC_REGEX, CUID2_REGEX, DECIMAL_REGEX, DIGITS_REGEX, EMAIL_REGEX, EMOJI_REGEX, HEXADECIMAL_REGEX, HEX_COLOR_REGEX, IMEI_REGEX, IPV4_REGEX, IPV6_REGEX, IP_REGEX, ISO_DATE_REGEX, ISO_DATE_TIME_REGEX, ISO_TIMESTAMP_REGEX, ISO_TIME_REGEX, ISO_TIME_SECOND_REGEX, ISO_WEEK_REGEX, MAC48_REGEX, MAC64_REGEX, MAC_REGEX, NANO_ID_REGEX, OCTAL_REGEX, RFC_EMAIL_REGEX, SLUG_REGEX, ULID_REGEX, UUID_REGEX, ValiError, _addIssue, _getByteCount, _getGraphemeCount, _getLastMetadata, _getStandardProps, _getWordCount, _isLuhnAlgo, _isValidObjectKey, _joinExpects, _stringify, any, args, argsAsync, array, arrayAsync, assert, awaitAsync, base64, bic, bigint, blob, boolean, brand, bytes, check, checkAsync, checkItems, checkItemsAsync, config, creditCard, cuid2, custom, customAsync, date, decimal, deleteGlobalConfig, deleteGlobalMessage, deleteSchemaMessage, deleteSpecificMessage, description, digits, email, emoji, empty, endsWith, entries, entriesFromList, entriesFromObjects, enum_ as enum, enum_, everyItem, exactOptional, exactOptionalAsync, examples, excludes, fallback, fallbackAsync, file, filterItems, findItem, finite, flatten, flavor, forward, forwardAsync, function_ as function, function_, getDefault, getDefaults, getDefaultsAsync, getDescription, getDotPath, getExamples, getFallback, getFallbacks, getFallbacksAsync, getGlobalConfig, getGlobalMessage, getMetadata, getSchemaMessage, getSpecificMessage, getTitle, graphemes, gtValue, hash, hexColor, hexadecimal, imei, includes, instance, integer, intersect, intersectAsync, ip, ipv4, ipv6, is, isOfKind, isOfType, isValiError, isoDate, isoDateTime, isoTime, isoTimeSecond, isoTimestamp, isoWeek, keyof, lazy, lazyAsync, length, literal, looseObject, looseObjectAsync, looseTuple, looseTupleAsync, ltValue, mac, mac48, mac64, map, mapAsync, mapItems, maxBytes, maxEntries, maxGraphemes, maxLength, maxSize, maxValue, maxWords, message, metadata, mimeType, minBytes, minEntries, minGraphemes, minLength, minSize, minValue, minWords, multipleOf, nan, nanoid, never, nonEmpty, nonNullable, nonNullableAsync, nonNullish, nonNullishAsync, nonOptional, nonOptionalAsync, normalize, notBytes, notEntries, notGraphemes, notLength, notSize, notValue, notValues, notWords, null_ as null, null_, nullable, nullableAsync, nullish, nullishAsync, number, object, objectAsync, objectWithRest, objectWithRestAsync, octal, omit, optional, optionalAsync, parse, parseAsync, parseJson, parser, parserAsync, partial, partialAsync, partialCheck, partialCheckAsync, pick, picklist, pipe, pipeAsync, promise, rawCheck, rawCheckAsync, rawTransform, rawTransformAsync, readonly, record, recordAsync, reduceItems, regex, required, requiredAsync, returns, returnsAsync, rfcEmail, safeInteger, safeParse, safeParseAsync, safeParser, safeParserAsync, set, setAsync, setGlobalConfig, setGlobalMessage, setSchemaMessage, setSpecificMessage, size, slug, someItem, sortItems, startsWith, strictObject, strictObjectAsync, strictTuple, strictTupleAsync, string, stringifyJson, summarize, symbol, title, toBigint, toBoolean, toDate, toLowerCase, toMaxValue, toMinValue, toNumber, toString, toUpperCase, transform, transformAsync, trim, trimEnd, trimStart, tuple, tupleAsync, tupleWithRest, tupleWithRestAsync, ulid, undefined_ as undefined, undefined_, undefinedable, undefinedableAsync, union, unionAsync, unknown, unwrap, url, uuid, value, values, variant, variantAsync, void_ as void, void_, words };", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape, EnumOutputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tcheck,\n\tinteger,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttransform,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { isValidSuiAddress, normalizeSuiAddress } from '../../utils/sui-types.js';\nimport type { Simplify } from '@mysten/utils';\n\ntype EnumSchemaInput<T extends Record<string, GenericSchema<any>>> = EnumInputShape<\n\tSimplify<{\n\t\t[K in keyof T]: InferInput<T[K]>;\n\t}>\n>;\n\ntype EnumSchemaOutput<T extends Record<string, GenericSchema<any>>> = EnumOutputShape<\n\tSimplify<{\n\t\t[K in keyof T]: InferOutput<T[K]>;\n\t}>\n>;\n\ntype EnumSchema<T extends Record<string, GenericSchema<any>>> = GenericSchema<\n\tEnumSchemaInput<T>,\n\tEnumSchemaOutput<T>\n>;\n\nexport function safeEnum<T extends Record<string, GenericSchema<any>>>(options: T): EnumSchema<T> {\n\tconst unionOptions = Object.entries(options).map(([key, value]) => object({ [key]: value }));\n\n\treturn pipe(\n\t\tunion(unionOptions),\n\t\ttransform(\n\t\t\t(value) =>\n\t\t\t\t({\n\t\t\t\t\t...value,\n\t\t\t\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t\t\t\t}) as EnumSchemaOutput<T>,\n\t\t),\n\t) as EnumSchema<T>;\n}\n\nexport const SuiAddress = pipe(\n\tstring(),\n\ttransform((value) => normalizeSuiAddress(value)),\n\tcheck(isValidSuiAddress),\n);\nexport const ObjectID = SuiAddress;\nexport const BCSBytes = string();\nexport const JsonU64 = pipe(\n\tunion([string(), pipe(number(), integer())]),\n\n\tcheck((val) => {\n\t\ttry {\n\t\t\tBigInt(val);\n\t\t\treturn BigInt(val) >= 0 && BigInt(val) <= 18446744073709551615n;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}, 'Invalid u64'),\n);\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/base_types.rs#L138\n// Implemented as a tuple in rust\nexport const ObjectRefSchema = object({\n\tobjectId: SuiAddress,\n\tversion: JsonU64,\n\tdigest: string(),\n});\nexport type ObjectRef = InferOutput<typeof ObjectRefSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nexport const ArgumentSchema = pipe(\n\tunion([\n\t\tobject({ GasCoin: literal(true) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('pure')) }),\n\t\tobject({ Input: pipe(number(), integer()), type: optional(literal('object')) }),\n\t\tobject({ Result: pipe(number(), integer()) }),\n\t\tobject({ NestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]) }),\n\t]),\n\ttransform((value) => ({\n\t\t...value,\n\t\t$kind: Object.keys(value)[0] as keyof typeof value,\n\t})),\n\t// Defined manually to add `type?: 'pure' | 'object'` to Input\n) as GenericSchema<\n\t// Input\n\t| { GasCoin: true }\n\t| { Input: number; type?: 'pure' | 'object' }\n\t| { Result: number }\n\t| { NestedResult: [number, number] },\n\t// Output\n\t| { $kind: 'GasCoin'; GasCoin: true }\n\t| { $kind: 'Input'; Input: number; type?: 'pure' }\n\t| { $kind: 'Input'; Input: number; type?: 'object' }\n\t| { $kind: 'Result'; Result: number }\n\t| { $kind: 'NestedResult'; NestedResult: [number, number] }\n>;\n\nexport type Argument = InferOutput<typeof ArgumentSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nexport const GasDataSchema = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRefSchema)),\n});\nexport type GasData = InferOutput<typeof GasDataSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTagSchema = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\t// type_params in rust, should be updated to use camelCase\n\ttypeParams: array(string()),\n});\nexport type StructTag = InferOutput<typeof StructTagSchema>;\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1614-L1627\nexport type OpenMoveTypeSignatureBody =\n\t| 'address'\n\t| 'bool'\n\t| 'u8'\n\t| 'u16'\n\t| 'u32'\n\t| 'u64'\n\t| 'u128'\n\t| 'u256'\n\t| { vector: OpenMoveTypeSignatureBody }\n\t| {\n\t\t\tdatatype: {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\ttype: string;\n\t\t\t\ttypeParameters: OpenMoveTypeSignatureBody[];\n\t\t\t};\n\t  }\n\t| { typeParameter: number };\n\nexport const OpenMoveTypeSignatureBodySchema: GenericSchema<OpenMoveTypeSignatureBody> = union([\n\tliteral('address'),\n\tliteral('bool'),\n\tliteral('u8'),\n\tliteral('u16'),\n\tliteral('u32'),\n\tliteral('u64'),\n\tliteral('u128'),\n\tliteral('u256'),\n\tobject({ vector: lazy(() => OpenMoveTypeSignatureBodySchema) }),\n\tobject({\n\t\tdatatype: object({\n\t\t\tpackage: string(),\n\t\t\tmodule: string(),\n\t\t\ttype: string(),\n\t\t\ttypeParameters: array(lazy(() => OpenMoveTypeSignatureBodySchema)),\n\t\t}),\n\t}),\n\tobject({ typeParameter: pipe(number(), integer()) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/crates/sui-graphql-rpc/schema/current_progress_schema.graphql#L1609-L1612\nexport const OpenMoveTypeSignatureSchema = object({\n\tref: nullable(union([literal('&'), literal('&mut')])),\n\tbody: OpenMoveTypeSignatureBodySchema,\n});\nexport type OpenMoveTypeSignature = InferOutput<typeof OpenMoveTypeSignatureSchema>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCallSchema = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(ArgumentSchema),\n\t_argumentTypes: optional(nullable(array(OpenMoveTypeSignatureSchema))),\n});\nexport type ProgrammableMoveCall = InferOutput<typeof ProgrammableMoveCallSchema>;\n\nexport const $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([ArgumentSchema, array(ArgumentSchema)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nexport const CommandSchema = safeEnum({\n\tMoveCall: ProgrammableMoveCallSchema,\n\tTransferObjects: object({\n\t\tobjects: array(ArgumentSchema),\n\t\taddress: ArgumentSchema,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: ArgumentSchema,\n\t\tamounts: array(ArgumentSchema),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: ArgumentSchema,\n\t\tsources: array(ArgumentSchema),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(ArgumentSchema),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: ArgumentSchema,\n\t}),\n\t$Intent,\n});\n\nexport type Command<Arg = Argument> = EnumOutputShape<{\n\tMoveCall: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t\ttypeArguments: string[];\n\t\targuments: Arg[];\n\t\t_argumentTypes?: OpenMoveTypeSignature[] | null;\n\t};\n\tTransferObjects: {\n\t\tobjects: Arg[];\n\t\taddress: Arg;\n\t};\n\tSplitCoins: {\n\t\tcoin: Arg;\n\t\tamounts: Arg[];\n\t};\n\tMergeCoins: {\n\t\tdestination: Arg;\n\t\tsources: Arg[];\n\t};\n\tPublish: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t};\n\tMakeMoveVec: {\n\t\ttype: string | null;\n\t\telements: Arg[];\n\t};\n\tUpgrade: {\n\t\tmodules: string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: Arg;\n\t};\n\t$Intent: {\n\t\tname: string;\n\t\tinputs: Record<string, Argument | Argument[]>;\n\t\tdata: Record<string, unknown>;\n\t};\n}>;\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nexport const ObjectArgSchema = safeEnum({\n\tImmOrOwnedObject: ObjectRefSchema,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRefSchema,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArgSchema = safeEnum({\n\tObject: ObjectArgSchema,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t\tmutable: optional(nullable(boolean())),\n\t}),\n});\nexport type CallArg = InferOutput<typeof CallArgSchema>;\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArgSchema,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n});\n\nexport const TransactionExpiration = safeEnum({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport type TransactionExpiration = InferOutput<typeof TransactionExpiration>;\n\nexport const TransactionDataSchema = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasDataSchema,\n\tinputs: array(CallArgSchema),\n\tcommands: array(CommandSchema),\n});\n\nexport type TransactionData = InferOutput<typeof TransactionDataSchema>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { normalizeSuiObjectId } from '../utils/sui-types.js';\nimport type { Argument, CallArg, Command } from './data/internal.js';\nimport { ArgumentSchema } from './data/internal.js';\nimport type { AsyncTransactionThunk, Transaction } from './Transaction.js';\n\nexport type TransactionArgument =\n\t| InferInput<typeof ArgumentSchema>\n\t| ((tx: Transaction) => InferInput<typeof ArgumentSchema>)\n\t| AsyncTransactionThunk;\nexport type TransactionInput = CallArg;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n\tCOMPATIBLE = 0,\n\tADDITIVE = 128,\n\tDEP_ONLY = 192,\n}\n\ntype TransactionShape<T extends Command['$kind']> = { $kind: T } & {\n\t[K in T]: Extract<Command, { [K in T]: any }>[T];\n};\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Commands = {\n\tMoveCall(\n\t\tinput:\n\t\t\t| {\n\t\t\t\t\tpackage: string;\n\t\t\t\t\tmodule: string;\n\t\t\t\t\tfunction: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  }\n\t\t\t| {\n\t\t\t\t\ttarget: string;\n\t\t\t\t\targuments?: Argument[];\n\t\t\t\t\ttypeArguments?: string[];\n\t\t\t  },\n\t): TransactionShape<'MoveCall'> {\n\t\tconst [pkg, mod = '', fn = ''] =\n\t\t\t'target' in input ? input.target.split('::') : [input.package, input.module, input.function];\n\n\t\treturn {\n\t\t\t$kind: 'MoveCall',\n\t\t\tMoveCall: {\n\t\t\t\tpackage: pkg,\n\t\t\t\tmodule: mod,\n\t\t\t\tfunction: fn,\n\t\t\t\ttypeArguments: input.typeArguments ?? [],\n\t\t\t\targuments: input.arguments ?? [],\n\t\t\t},\n\t\t};\n\t},\n\n\tTransferObjects(\n\t\tobjects: InferInput<typeof ArgumentSchema>[],\n\t\taddress: InferInput<typeof ArgumentSchema>,\n\t): TransactionShape<'TransferObjects'> {\n\t\treturn {\n\t\t\t$kind: 'TransferObjects',\n\t\t\tTransferObjects: {\n\t\t\t\tobjects: objects.map((o) => parse(ArgumentSchema, o)),\n\t\t\t\taddress: parse(ArgumentSchema, address),\n\t\t\t},\n\t\t};\n\t},\n\tSplitCoins(\n\t\tcoin: InferInput<typeof ArgumentSchema>,\n\t\tamounts: InferInput<typeof ArgumentSchema>[],\n\t): TransactionShape<'SplitCoins'> {\n\t\treturn {\n\t\t\t$kind: 'SplitCoins',\n\t\t\tSplitCoins: {\n\t\t\t\tcoin: parse(ArgumentSchema, coin),\n\t\t\t\tamounts: amounts.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tMergeCoins(\n\t\tdestination: InferInput<typeof ArgumentSchema>,\n\t\tsources: InferInput<typeof ArgumentSchema>[],\n\t): TransactionShape<'MergeCoins'> {\n\t\treturn {\n\t\t\t$kind: 'MergeCoins',\n\t\t\tMergeCoins: {\n\t\t\t\tdestination: parse(ArgumentSchema, destination),\n\t\t\t\tsources: sources.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tPublish({\n\t\tmodules,\n\t\tdependencies,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t}): TransactionShape<'Publish'> {\n\t\treturn {\n\t\t\t$kind: 'Publish',\n\t\t\tPublish: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t},\n\t\t};\n\t},\n\tUpgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: InferInput<typeof ArgumentSchema>;\n\t}): TransactionShape<'Upgrade'> {\n\t\treturn {\n\t\t\t$kind: 'Upgrade',\n\t\t\tUpgrade: {\n\t\t\t\tmodules: modules.map((module) =>\n\t\t\t\t\ttypeof module === 'string' ? module : toBase64(new Uint8Array(module)),\n\t\t\t\t),\n\t\t\t\tdependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: parse(ArgumentSchema, ticket),\n\t\t\t},\n\t\t};\n\t},\n\tMakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\ttype?: string;\n\t\telements: InferInput<typeof ArgumentSchema>[];\n\t}): TransactionShape<'MakeMoveVec'> {\n\t\treturn {\n\t\t\t$kind: 'MakeMoveVec',\n\t\t\tMakeMoveVec: {\n\t\t\t\ttype: type ?? null,\n\t\t\t\telements: elements.map((o) => parse(ArgumentSchema, o)),\n\t\t\t},\n\t\t};\n\t},\n\tIntent({\n\t\tname,\n\t\tinputs = {},\n\t\tdata = {},\n\t}: {\n\t\tname: string;\n\t\tinputs?: Record<\n\t\t\tstring,\n\t\t\tInferInput<typeof ArgumentSchema> | InferInput<typeof ArgumentSchema>[]\n\t\t>;\n\t\tdata?: Record<string, unknown>;\n\t}): TransactionShape<'$Intent'> {\n\t\treturn {\n\t\t\t$kind: '$Intent',\n\t\t\t$Intent: {\n\t\t\t\tname,\n\t\t\t\tinputs: Object.fromEntries(\n\t\t\t\t\tObject.entries(inputs).map(([key, value]) => [\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tArray.isArray(value)\n\t\t\t\t\t\t\t? value.map((o) => parse(ArgumentSchema, o))\n\t\t\t\t\t\t\t: parse(ArgumentSchema, value),\n\t\t\t\t\t]),\n\t\t\t\t),\n\t\t\t\tdata,\n\t\t\t},\n\t\t};\n\t},\n};\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { is } from 'valibot';\n\nimport type { SuiMoveNormalizedType } from '../client/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport { ArgumentSchema } from './data/internal.js';\nimport type { Argument, CallArg, Command } from './data/internal.js';\n\nexport function extractMutableReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'MutableReference' in normalizedType\n\t\t? normalizedType.MutableReference\n\t\t: undefined;\n}\n\nexport function extractReference(\n\tnormalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n\treturn typeof normalizedType === 'object' && 'Reference' in normalizedType\n\t\t? normalizedType.Reference\n\t\t: undefined;\n}\n\nexport function extractStructTag(\n\tnormalizedType: SuiMoveNormalizedType,\n): Extract<SuiMoveNormalizedType, { Struct: unknown }> | undefined {\n\tif (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n\t\treturn normalizedType;\n\t}\n\n\tconst ref = extractReference(normalizedType);\n\tconst mutRef = extractMutableReference(normalizedType);\n\n\tif (typeof ref === 'object' && 'Struct' in ref) {\n\t\treturn ref;\n\t}\n\n\tif (typeof mutRef === 'object' && 'Struct' in mutRef) {\n\t\treturn mutRef;\n\t}\n\treturn undefined;\n}\n\nexport function getIdFromCallArg(arg: string | CallArg) {\n\tif (typeof arg === 'string') {\n\t\treturn normalizeSuiAddress(arg);\n\t}\n\n\tif (arg.Object) {\n\t\tif (arg.Object.ImmOrOwnedObject) {\n\t\t\treturn normalizeSuiAddress(arg.Object.ImmOrOwnedObject.objectId);\n\t\t}\n\n\t\tif (arg.Object.Receiving) {\n\t\t\treturn normalizeSuiAddress(arg.Object.Receiving.objectId);\n\t\t}\n\n\t\treturn normalizeSuiAddress(arg.Object.SharedObject.objectId);\n\t}\n\n\tif (arg.UnresolvedObject) {\n\t\treturn normalizeSuiAddress(arg.UnresolvedObject.objectId);\n\t}\n\n\treturn undefined;\n}\n\nexport function isArgument(value: unknown): value is Argument {\n\treturn is(ArgumentSchema, value);\n}\n\nexport function remapCommandArguments(\n\tcommand: Command,\n\tinputMapping: Map<number, number>,\n\tcommandMapping: Map<number, number>,\n) {\n\tconst remapArg = (arg: Argument): Argument => {\n\t\tswitch (arg.$kind) {\n\t\t\tcase 'Input': {\n\t\t\t\tconst newInputIndex = inputMapping.get(arg.Input);\n\t\t\t\tif (newInputIndex === undefined) {\n\t\t\t\t\tthrow new Error(`Input ${arg.Input} not found in input mapping`);\n\t\t\t\t}\n\t\t\t\treturn { ...arg, Input: newInputIndex };\n\t\t\t}\n\t\t\tcase 'Result': {\n\t\t\t\tconst newCommandIndex = commandMapping.get(arg.Result);\n\t\t\t\tif (newCommandIndex !== undefined) {\n\t\t\t\t\treturn { ...arg, Result: newCommandIndex };\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t}\n\t\t\tcase 'NestedResult': {\n\t\t\t\tconst newCommandIndex = commandMapping.get(arg.NestedResult[0]);\n\t\t\t\tif (newCommandIndex !== undefined) {\n\t\t\t\t\treturn { ...arg, NestedResult: [newCommandIndex, arg.NestedResult[1]] };\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn arg;\n\t\t}\n\t};\n\n\tswitch (command.$kind) {\n\t\tcase 'MoveCall':\n\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'TransferObjects':\n\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map(remapArg);\n\t\t\tcommand.TransferObjects.address = remapArg(command.TransferObjects.address);\n\t\t\tbreak;\n\t\tcase 'SplitCoins':\n\t\t\tcommand.SplitCoins.coin = remapArg(command.SplitCoins.coin);\n\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'MergeCoins':\n\t\t\tcommand.MergeCoins.destination = remapArg(command.MergeCoins.destination);\n\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'MakeMoveVec':\n\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map(remapArg);\n\t\t\tbreak;\n\t\tcase 'Upgrade':\n\t\t\tcommand.Upgrade.ticket = remapArg(command.Upgrade.ticket);\n\t\t\tbreak;\n\t\tcase '$Intent': {\n\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value) ? value.map(remapArg) : remapArg(value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 'Publish':\n\t\t\tbreak;\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromBase64, toBase64 } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tbigint,\n\tboolean,\n\tcheck,\n\tinteger,\n\tis,\n\tlazy,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tparse,\n\tpipe,\n\tstring,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { TypeTagSerializer } from '../../bcs/index.js';\nimport type { StructTag as StructTagType, TypeTag as TypeTagType } from '../../bcs/types.js';\nimport { JsonU64, ObjectID, safeEnum, TransactionDataSchema } from './internal.js';\nimport type { Argument, ArgumentSchema, TransactionData } from './internal.js';\n\nexport const ObjectRef = object({\n\tdigest: string(),\n\tobjectId: string(),\n\tversion: union([pipe(number(), integer()), string(), bigint()]),\n});\n\nconst ObjectArg = safeEnum({\n\tImmOrOwned: ObjectRef,\n\tShared: object({\n\t\tobjectId: ObjectID,\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRef,\n});\n\nexport const NormalizedCallArg = safeEnum({\n\tObject: ObjectArg,\n\tPure: array(pipe(number(), integer())),\n});\n\nconst TransactionInput = union([\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: optional(literal('object')),\n\t}),\n\tobject({\n\t\tkind: literal('Input'),\n\t\tindex: pipe(number(), integer()),\n\t\tvalue: unknown(),\n\t\ttype: literal('pure'),\n\t}),\n]);\n\nconst TransactionExpiration = union([\n\tobject({ Epoch: pipe(number(), integer()) }),\n\tobject({ None: nullable(literal(true)) }),\n]);\n\nconst StringEncodedBigint = pipe(\n\tunion([number(), string(), bigint()]),\n\tcheck((val) => {\n\t\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\t\ttry {\n\t\t\tBigInt(val as string);\n\t\t\treturn true;\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}),\n);\n\nexport const TypeTag: GenericSchema<TypeTagType> = union([\n\tobject({ bool: nullable(literal(true)) }),\n\tobject({ u8: nullable(literal(true)) }),\n\tobject({ u64: nullable(literal(true)) }),\n\tobject({ u128: nullable(literal(true)) }),\n\tobject({ address: nullable(literal(true)) }),\n\tobject({ signer: nullable(literal(true)) }),\n\tobject({ vector: lazy(() => TypeTag) }),\n\tobject({ struct: lazy(() => StructTag) }),\n\tobject({ u16: nullable(literal(true)) }),\n\tobject({ u32: nullable(literal(true)) }),\n\tobject({ u256: nullable(literal(true)) }),\n]);\n\n// https://github.com/MystenLabs/sui/blob/cea8742e810142a8145fd83c4c142d61e561004a/external-crates/move/crates/move-core-types/src/language_storage.rs#L140-L147\nexport const StructTag: GenericSchema<StructTagType> = object({\n\taddress: string(),\n\tmodule: string(),\n\tname: string(),\n\ttypeParams: array(TypeTag),\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(ObjectRef)),\n\towner: optional(string()),\n});\n\nconst TransactionArgumentTypes = [\n\tTransactionInput,\n\tobject({ kind: literal('GasCoin') }),\n\tobject({ kind: literal('Result'), index: pipe(number(), integer()) }),\n\tobject({\n\t\tkind: literal('NestedResult'),\n\t\tindex: pipe(number(), integer()),\n\t\tresultIndex: pipe(number(), integer()),\n\t}),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\n\nconst MoveCallTransaction = object({\n\tkind: literal('MoveCall'),\n\ttarget: pipe(\n\t\tstring(),\n\t\tcheck((target) => target.split('::').length === 3),\n\t) as GenericSchema<`${string}::${string}::${string}`>,\n\ttypeArguments: array(string()),\n\targuments: array(TransactionArgument),\n});\n\nconst TransferObjectsTransaction = object({\n\tkind: literal('TransferObjects'),\n\tobjects: array(TransactionArgument),\n\taddress: TransactionArgument,\n});\n\nconst SplitCoinsTransaction = object({\n\tkind: literal('SplitCoins'),\n\tcoin: TransactionArgument,\n\tamounts: array(TransactionArgument),\n});\n\nconst MergeCoinsTransaction = object({\n\tkind: literal('MergeCoins'),\n\tdestination: TransactionArgument,\n\tsources: array(TransactionArgument),\n});\n\nconst MakeMoveVecTransaction = object({\n\tkind: literal('MakeMoveVec'),\n\ttype: union([object({ Some: TypeTag }), object({ None: nullable(literal(true)) })]),\n\tobjects: array(TransactionArgument),\n});\n\nconst PublishTransaction = object({\n\tkind: literal('Publish'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n});\n\nconst UpgradeTransaction = object({\n\tkind: literal('Upgrade'),\n\tmodules: array(array(pipe(number(), integer()))),\n\tdependencies: array(string()),\n\tpackageId: string(),\n\tticket: TransactionArgument,\n});\n\nconst TransactionTypes = [\n\tMoveCallTransaction,\n\tTransferObjectsTransaction,\n\tSplitCoinsTransaction,\n\tMergeCoinsTransaction,\n\tPublishTransaction,\n\tUpgradeTransaction,\n\tMakeMoveVecTransaction,\n] as const;\n\nconst TransactionType = union([...TransactionTypes]);\n\nexport const SerializedTransactionDataV1 = object({\n\tversion: literal(1),\n\tsender: optional(string()),\n\texpiration: nullish(TransactionExpiration),\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionInput),\n\ttransactions: array(TransactionType),\n});\n\nexport type SerializedTransactionDataV1 = InferOutput<typeof SerializedTransactionDataV1>;\n\nexport function serializeV1TransactionData(\n\ttransactionData: TransactionData,\n): SerializedTransactionDataV1 {\n\tconst inputs: InferOutput<typeof TransactionInput>[] = transactionData.inputs.map(\n\t\t(input, index) => {\n\t\t\tif (input.Object) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tObject: input.Object.ImmOrOwnedObject\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tImmOrOwned: input.Object.ImmOrOwnedObject,\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: input.Object.Receiving\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\t\tdigest: input.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\t\tversion: input.Object.Receiving.version,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tShared: {\n\t\t\t\t\t\t\t\t\t\t\tmutable: input.Object.SharedObject.mutable,\n\t\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: input.Object.SharedObject.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\t\tobjectId: input.Object.SharedObject.objectId,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'object',\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (input.Pure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: {\n\t\t\t\t\t\tPure: Array.from(fromBase64(input.Pure.bytes)),\n\t\t\t\t\t},\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedPure) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'pure',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedPure.value,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (input.UnresolvedObject) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Input',\n\t\t\t\t\ttype: 'object',\n\t\t\t\t\tindex,\n\t\t\t\t\tvalue: input.UnresolvedObject.objectId,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t},\n\t);\n\n\treturn {\n\t\tversion: 1,\n\t\tsender: transactionData.sender ?? undefined,\n\t\texpiration:\n\t\t\ttransactionData.expiration?.$kind === 'Epoch'\n\t\t\t\t? { Epoch: Number(transactionData.expiration.Epoch) }\n\t\t\t\t: transactionData.expiration\n\t\t\t\t\t? { None: true }\n\t\t\t\t\t: null,\n\t\tgasConfig: {\n\t\t\towner: transactionData.gasData.owner ?? undefined,\n\t\t\tbudget: transactionData.gasData.budget ?? undefined,\n\t\t\tprice: transactionData.gasData.price ?? undefined,\n\t\t\tpayment: transactionData.gasData.payment ?? undefined,\n\t\t},\n\t\tinputs,\n\t\ttransactions: transactionData.commands.map((command): InferOutput<typeof TransactionType> => {\n\t\t\tif (command.MakeMoveVec) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MakeMoveVec',\n\t\t\t\t\ttype:\n\t\t\t\t\t\tcommand.MakeMoveVec.type === null\n\t\t\t\t\t\t\t? { None: true }\n\t\t\t\t\t\t\t: { Some: TypeTagSerializer.parseFromStr(command.MakeMoveVec.type) },\n\t\t\t\t\tobjects: command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MergeCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MergeCoins',\n\t\t\t\t\tdestination: convertTransactionArgument(command.MergeCoins.destination, inputs),\n\t\t\t\t\tsources: command.MergeCoins.sources.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.MoveCall) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'MoveCall',\n\t\t\t\t\ttarget: `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`,\n\t\t\t\t\ttypeArguments: command.MoveCall.typeArguments,\n\t\t\t\t\targuments: command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.Publish) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Publish',\n\t\t\t\t\tmodules: command.Publish.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Publish.dependencies,\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.SplitCoins) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'SplitCoins',\n\t\t\t\t\tcoin: convertTransactionArgument(command.SplitCoins.coin, inputs),\n\t\t\t\t\tamounts: command.SplitCoins.amounts.map((arg) => convertTransactionArgument(arg, inputs)),\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (command.TransferObjects) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'TransferObjects',\n\t\t\t\t\tobjects: command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\t\tconvertTransactionArgument(arg, inputs),\n\t\t\t\t\t),\n\t\t\t\t\taddress: convertTransactionArgument(command.TransferObjects.address, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (command.Upgrade) {\n\t\t\t\treturn {\n\t\t\t\t\tkind: 'Upgrade',\n\t\t\t\t\tmodules: command.Upgrade.modules.map((mod) => Array.from(fromBase64(mod))),\n\t\t\t\t\tdependencies: command.Upgrade.dependencies,\n\t\t\t\t\tpackageId: command.Upgrade.package,\n\t\t\t\t\tticket: convertTransactionArgument(command.Upgrade.ticket, inputs),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(command)}`);\n\t\t}),\n\t};\n}\n\nfunction convertTransactionArgument(\n\targ: Argument,\n\tinputs: InferOutput<typeof TransactionInput>[],\n): InferOutput<typeof TransactionArgument> {\n\tif (arg.$kind === 'GasCoin') {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\tif (arg.$kind === 'Result') {\n\t\treturn { kind: 'Result', index: arg.Result };\n\t}\n\tif (arg.$kind === 'NestedResult') {\n\t\treturn { kind: 'NestedResult', index: arg.NestedResult[0], resultIndex: arg.NestedResult[1] };\n\t}\n\tif (arg.$kind === 'Input') {\n\t\treturn inputs[arg.Input];\n\t}\n\n\tthrow new Error(`Invalid argument ${Object.keys(arg)}`);\n}\n\nexport function transactionDataFromV1(data: SerializedTransactionDataV1): TransactionData {\n\treturn parse(TransactionDataSchema, {\n\t\tversion: 2,\n\t\tsender: data.sender ?? null,\n\t\texpiration: data.expiration\n\t\t\t? 'Epoch' in data.expiration\n\t\t\t\t? { Epoch: data.expiration.Epoch }\n\t\t\t\t: { None: true }\n\t\t\t: null,\n\t\tgasData: {\n\t\t\towner: data.gasConfig.owner ?? null,\n\t\t\tbudget: data.gasConfig.budget?.toString() ?? null,\n\t\t\tprice: data.gasConfig.price?.toString() ?? null,\n\t\t\tpayment:\n\t\t\t\tdata.gasConfig.payment?.map((ref) => ({\n\t\t\t\t\tdigest: ref.digest,\n\t\t\t\t\tobjectId: ref.objectId,\n\t\t\t\t\tversion: ref.version.toString(),\n\t\t\t\t})) ?? null,\n\t\t},\n\t\tinputs: data.inputs.map((input) => {\n\t\t\tif (input.kind === 'Input') {\n\t\t\t\tif (is(NormalizedCallArg, input.value)) {\n\t\t\t\t\tconst value = parse(NormalizedCallArg, input.value);\n\n\t\t\t\t\tif (value.Object) {\n\t\t\t\t\t\tif (value.Object.ImmOrOwned) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tImmOrOwnedObject: {\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.ImmOrOwned.objectId,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.ImmOrOwned.version),\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.ImmOrOwned.digest,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Shared) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tSharedObject: {\n\t\t\t\t\t\t\t\t\t\tmutable: value.Object.Shared.mutable ?? null,\n\t\t\t\t\t\t\t\t\t\tinitialSharedVersion: value.Object.Shared.initialSharedVersion,\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Shared.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (value.Object.Receiving) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tObject: {\n\t\t\t\t\t\t\t\t\tReceiving: {\n\t\t\t\t\t\t\t\t\t\tdigest: value.Object.Receiving.digest,\n\t\t\t\t\t\t\t\t\t\tversion: String(value.Object.Receiving.version),\n\t\t\t\t\t\t\t\t\t\tobjectId: value.Object.Receiving.objectId,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error('Invalid object input');\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: toBase64(new Uint8Array(value.Pure)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'object') {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: input.value as string,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\tUnresolvedPure: {\n\t\t\t\t\t\tvalue: input.value,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthrow new Error('Invalid input');\n\t\t}),\n\t\tcommands: data.transactions.map((transaction) => {\n\t\t\tswitch (transaction.kind) {\n\t\t\t\tcase 'MakeMoveVec':\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMakeMoveVec: {\n\t\t\t\t\t\t\ttype:\n\t\t\t\t\t\t\t\t'Some' in transaction.type\n\t\t\t\t\t\t\t\t\t? TypeTagSerializer.tagToString(transaction.type.Some)\n\t\t\t\t\t\t\t\t\t: null,\n\t\t\t\t\t\t\telements: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\tcase 'MergeCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMergeCoins: {\n\t\t\t\t\t\t\tdestination: parseV1TransactionArgument(transaction.destination),\n\t\t\t\t\t\t\tsources: transaction.sources.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'MoveCall': {\n\t\t\t\t\tconst [pkg, mod, fn] = transaction.target.split('::');\n\t\t\t\t\treturn {\n\t\t\t\t\t\tMoveCall: {\n\t\t\t\t\t\t\tpackage: pkg,\n\t\t\t\t\t\t\tmodule: mod,\n\t\t\t\t\t\t\tfunction: fn,\n\t\t\t\t\t\t\ttypeArguments: transaction.typeArguments,\n\t\t\t\t\t\t\targuments: transaction.arguments.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Publish': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tPublish: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'SplitCoins': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tSplitCoins: {\n\t\t\t\t\t\t\tcoin: parseV1TransactionArgument(transaction.coin),\n\t\t\t\t\t\t\tamounts: transaction.amounts.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'TransferObjects': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tTransferObjects: {\n\t\t\t\t\t\t\tobjects: transaction.objects.map((arg) => parseV1TransactionArgument(arg)),\n\t\t\t\t\t\t\taddress: parseV1TransactionArgument(transaction.address),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tcase 'Upgrade': {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tUpgrade: {\n\t\t\t\t\t\t\tmodules: transaction.modules.map((mod) => toBase64(Uint8Array.from(mod))),\n\t\t\t\t\t\t\tdependencies: transaction.dependencies,\n\t\t\t\t\t\t\tpackage: transaction.packageId,\n\t\t\t\t\t\t\tticket: parseV1TransactionArgument(transaction.ticket),\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error(`Unknown transaction ${Object.keys(transaction)}`);\n\t\t}),\n\t} satisfies InferInput<typeof TransactionDataSchema>);\n}\n\nfunction parseV1TransactionArgument(\n\targ: InferOutput<typeof TransactionArgument>,\n): InferInput<typeof ArgumentSchema> {\n\tswitch (arg.kind) {\n\t\tcase 'GasCoin': {\n\t\t\treturn { GasCoin: true };\n\t\t}\n\t\tcase 'Result':\n\t\t\treturn { Result: arg.index };\n\t\tcase 'NestedResult': {\n\t\t\treturn { NestedResult: [arg.index, arg.resultIndex] };\n\t\t}\n\t\tcase 'Input': {\n\t\t\treturn { Input: arg.index };\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n\tconst typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n\tconst dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n\tdataWithTag.set(typeTagBytes);\n\tdataWithTag.set(data, typeTagBytes.length);\n\n\treturn blake2b(dataWithTag, { dkLen: 32 });\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase58 } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { parse } from 'valibot';\n\nimport { bcs } from '../bcs/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type {\n\tArgument,\n\tCallArg,\n\tCommand,\n\tGasData,\n\tTransactionExpiration,\n\tTransactionData,\n} from './data/internal.js';\nimport { ArgumentSchema, TransactionDataSchema } from './data/internal.js';\nimport { transactionDataFromV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV1 } from './data/v1.js';\nimport type { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { hashTypedData } from './hash.js';\nimport { getIdFromCallArg, remapCommandArguments } from './utils.js';\nimport type { TransactionResult } from './Transaction.js';\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionDataBuilder implements TransactionData {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = bcs.TransactionKind.parse(bytes);\n\n\t\tconst programmableTx = kind.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: null,\n\t\t\texpiration: null,\n\t\t\tgasData: {\n\t\t\t\tbudget: null,\n\t\t\t\towner: null,\n\t\t\t\tpayment: null,\n\t\t\t\tprice: null,\n\t\t\t},\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = bcs.TransactionData.parse(bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data.kind.ProgrammableTransaction;\n\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\treturn TransactionDataBuilder.restore({\n\t\t\tversion: 2,\n\t\t\tsender: data.sender,\n\t\t\texpiration: data.expiration,\n\t\t\tgasData: data.gasData,\n\t\t\tinputs: programmableTx.inputs,\n\t\t\tcommands: programmableTx.commands,\n\t\t});\n\t}\n\n\tstatic restore(\n\t\tdata:\n\t\t\t| InferInput<typeof SerializedTransactionDataV2Schema>\n\t\t\t| InferInput<typeof SerializedTransactionDataV1>,\n\t) {\n\t\tif (data.version === 2) {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, data));\n\t\t} else {\n\t\t\treturn new TransactionDataBuilder(parse(TransactionDataSchema, transactionDataFromV1(data)));\n\t\t}\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toBase58(hash);\n\t}\n\n\t// @deprecated use gasData instead\n\tget gasConfig() {\n\t\treturn this.gasData;\n\t}\n\t// @deprecated use gasData instead\n\tset gasConfig(value) {\n\t\tthis.gasData = value;\n\t}\n\n\tversion = 2 as const;\n\tsender: string | null;\n\texpiration: TransactionExpiration | null;\n\tgasData: GasData;\n\tinputs: CallArg[];\n\tcommands: Command[];\n\n\tconstructor(clone?: TransactionData) {\n\t\tthis.sender = clone?.sender ?? null;\n\t\tthis.expiration = clone?.expiration ?? null;\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.commands = clone?.commands ?? [];\n\t\tthis.gasData = clone?.gasData ?? {\n\t\t\tbudget: null,\n\t\t\tprice: null,\n\t\t\towner: null,\n\t\t\tpayment: null,\n\t\t};\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: {\n\t\t\texpiration?: TransactionExpiration;\n\t\t\tsender?: string;\n\t\t\t// @deprecated use gasData instead\n\t\t\tgasConfig?: Partial<GasData>;\n\t\t\tgasData?: Partial<GasData>;\n\t\t};\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// TODO validate that inputs and intents are actually resolved\n\t\tconst inputs = this.inputs as (typeof bcs.CallArg.$inferInput)[];\n\t\tconst commands = this.commands as Extract<\n\t\t\tCommand<Exclude<Argument, { IntentResult: unknown } | { NestedIntentResult: unknown }>>,\n\t\t\t{ Upgrade: unknown }\n\t\t>[];\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\tcommands,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn bcs.TransactionKind.serialize(kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasData = { ...this.gasData, ...overrides?.gasConfig, ...overrides?.gasData };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasData.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasData.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasData.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasData.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasData.owner ?? sender),\n\t\t\t\tprice: BigInt(gasData.price),\n\t\t\t\tbudget: BigInt(gasData.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\tcommands,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn bcs.TransactionData.serialize(\n\t\t\t{ V1: transactionData },\n\t\t\t{ maxSize: maxSizeBytes },\n\t\t).toBytes();\n\t}\n\n\taddInput<T extends 'object' | 'pure'>(type: T, arg: CallArg) {\n\t\tconst index = this.inputs.length;\n\t\tthis.inputs.push(arg);\n\t\treturn { Input: index, type, $kind: 'Input' as const };\n\t}\n\n\tgetInputUses(index: number, fn: (arg: Argument, command: Command) => void) {\n\t\tthis.mapArguments((arg, command) => {\n\t\t\tif (arg.$kind === 'Input' && arg.Input === index) {\n\t\t\t\tfn(arg, command);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\tmapCommandArguments(\n\t\tindex: number,\n\t\tfn: (arg: Argument, command: Command, commandIndex: number) => Argument,\n\t) {\n\t\tconst command = this.commands[index];\n\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MoveCall':\n\t\t\t\tcommand.MoveCall.arguments = command.MoveCall.arguments.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tcommand.TransferObjects.objects = command.TransferObjects.objects.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tcommand.TransferObjects.address = fn(command.TransferObjects.address, command, index);\n\t\t\t\tbreak;\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.coin = fn(command.SplitCoins.coin, command, index);\n\t\t\t\tcommand.SplitCoins.amounts = command.SplitCoins.amounts.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MergeCoins':\n\t\t\t\tcommand.MergeCoins.destination = fn(command.MergeCoins.destination, command, index);\n\t\t\t\tcommand.MergeCoins.sources = command.MergeCoins.sources.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tcommand.MakeMoveVec.elements = command.MakeMoveVec.elements.map((arg) =>\n\t\t\t\t\tfn(arg, command, index),\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase 'Upgrade':\n\t\t\t\tcommand.Upgrade.ticket = fn(command.Upgrade.ticket, command, index);\n\t\t\t\tbreak;\n\t\t\tcase '$Intent':\n\t\t\t\tconst inputs = command.$Intent.inputs;\n\t\t\t\tcommand.$Intent.inputs = {};\n\n\t\t\t\tfor (const [key, value] of Object.entries(inputs)) {\n\t\t\t\t\tcommand.$Intent.inputs[key] = Array.isArray(value)\n\t\t\t\t\t\t? value.map((arg) => fn(arg, command, index))\n\t\t\t\t\t\t: fn(value, command, index);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'Publish':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unexpected transaction kind: ${(command as { $kind: unknown }).$kind}`);\n\t\t}\n\t}\n\n\tmapArguments(fn: (arg: Argument, command: Command, commandIndex: number) => Argument) {\n\t\tfor (const commandIndex of this.commands.keys()) {\n\t\t\tthis.mapCommandArguments(commandIndex, fn);\n\t\t}\n\t}\n\n\treplaceCommand(\n\t\tindex: number,\n\t\treplacement: Command | Command[],\n\t\tresultIndex: number | { Result: number } | { NestedResult: [number, number] } = index,\n\t) {\n\t\tif (!Array.isArray(replacement)) {\n\t\t\tthis.commands[index] = replacement;\n\t\t\treturn;\n\t\t}\n\n\t\tconst sizeDiff = replacement.length - 1;\n\n\t\tthis.commands.splice(index, 1, ...structuredClone(replacement));\n\n\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\tif (commandIndex < index + replacement.length) {\n\t\t\t\treturn arg;\n\t\t\t}\n\n\t\t\tif (typeof resultIndex !== 'number') {\n\t\t\t\tif (\n\t\t\t\t\t(arg.$kind === 'Result' && arg.Result === index) ||\n\t\t\t\t\t(arg.$kind === 'NestedResult' && arg.NestedResult[0] === index)\n\t\t\t\t) {\n\t\t\t\t\tif (!('NestedResult' in arg) || arg.NestedResult[1] === 0) {\n\t\t\t\t\t\treturn parse(ArgumentSchema, structuredClone(resultIndex));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot replace command ${index} with a specific result type: NestedResult[${index}, ${arg.NestedResult[1]}] references a nested element that cannot be mapped to the replacement result`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Handle adjustment of other references\n\t\t\tswitch (arg.$kind) {\n\t\t\t\tcase 'Result':\n\t\t\t\t\tif (arg.Result === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\targ.Result = resultIndex;\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.Result > index) {\n\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NestedResult':\n\t\t\t\t\tif (arg.NestedResult[0] === index && typeof resultIndex === 'number') {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t$kind: 'NestedResult',\n\t\t\t\t\t\t\tNestedResult: [resultIndex, arg.NestedResult[1]],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.NestedResult[0] > index) {\n\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn arg;\n\t\t});\n\t}\n\n\treplaceCommandWithTransaction(\n\t\tindex: number,\n\t\totherTransaction: TransactionData,\n\t\tresult: TransactionResult,\n\t) {\n\t\tif (result.$kind !== 'Result' && result.$kind !== 'NestedResult') {\n\t\t\tthrow new Error('Result must be of kind Result or NestedResult');\n\t\t}\n\n\t\tthis.insertTransaction(index, otherTransaction);\n\n\t\tthis.replaceCommand(\n\t\t\tindex + otherTransaction.commands.length,\n\t\t\t[],\n\t\t\t'Result' in result\n\t\t\t\t? { NestedResult: [result.Result + index, 0] }\n\t\t\t\t: {\n\t\t\t\t\t\tNestedResult: [\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[0] + index,\n\t\t\t\t\t\t\t(result as { NestedResult: [number, number] }).NestedResult[1],\n\t\t\t\t\t\t] as [number, number],\n\t\t\t\t\t},\n\t\t);\n\t}\n\n\tinsertTransaction(atCommandIndex: number, otherTransaction: TransactionData) {\n\t\tconst inputMapping = new Map<number, number>();\n\t\tconst commandMapping = new Map<number, number>();\n\n\t\tfor (let i = 0; i < otherTransaction.inputs.length; i++) {\n\t\t\tconst otherInput = otherTransaction.inputs[i];\n\t\t\tconst id = getIdFromCallArg(otherInput);\n\n\t\t\tlet existingIndex = -1;\n\t\t\tif (id !== undefined) {\n\t\t\t\texistingIndex = this.inputs.findIndex((input) => getIdFromCallArg(input) === id);\n\n\t\t\t\tif (\n\t\t\t\t\texistingIndex !== -1 &&\n\t\t\t\t\tthis.inputs[existingIndex].Object?.SharedObject &&\n\t\t\t\t\totherInput.Object?.SharedObject\n\t\t\t\t) {\n\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable =\n\t\t\t\t\t\tthis.inputs[existingIndex].Object!.SharedObject!.mutable ||\n\t\t\t\t\t\totherInput.Object.SharedObject.mutable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (existingIndex !== -1) {\n\t\t\t\tinputMapping.set(i, existingIndex);\n\t\t\t} else {\n\t\t\t\tconst newIndex = this.inputs.length;\n\t\t\t\tthis.inputs.push(otherInput);\n\t\t\t\tinputMapping.set(i, newIndex);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tcommandMapping.set(i, atCommandIndex + i);\n\t\t}\n\n\t\tconst remappedCommands: Command[] = [];\n\t\tfor (let i = 0; i < otherTransaction.commands.length; i++) {\n\t\t\tconst command = structuredClone(otherTransaction.commands[i]);\n\n\t\t\tremapCommandArguments(command, inputMapping, commandMapping);\n\n\t\t\tremappedCommands.push(command);\n\t\t}\n\n\t\tthis.commands.splice(atCommandIndex, 0, ...remappedCommands);\n\n\t\tconst sizeDiff = remappedCommands.length;\n\t\tif (sizeDiff > 0) {\n\t\t\tthis.mapArguments((arg, _command, commandIndex) => {\n\t\t\t\tif (\n\t\t\t\t\tcommandIndex >= atCommandIndex &&\n\t\t\t\t\tcommandIndex < atCommandIndex + remappedCommands.length\n\t\t\t\t) {\n\t\t\t\t\treturn arg;\n\t\t\t\t}\n\n\t\t\t\tswitch (arg.$kind) {\n\t\t\t\t\tcase 'Result':\n\t\t\t\t\t\tif (arg.Result >= atCommandIndex) {\n\t\t\t\t\t\t\targ.Result += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'NestedResult':\n\t\t\t\t\t\tif (arg.NestedResult[0] >= atCommandIndex) {\n\t\t\t\t\t\t\targ.NestedResult[0] += sizeDiff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn arg;\n\t\t\t});\n\t\t}\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): TransactionData {\n\t\treturn parse(TransactionDataSchema, this);\n\t}\n\n\tshallowClone() {\n\t\treturn new TransactionDataBuilder({\n\t\t\tversion: this.version,\n\t\t\tsender: this.sender,\n\t\t\texpiration: this.expiration,\n\t\t\tgasData: {\n\t\t\t\t...this.gasData,\n\t\t\t},\n\t\t\tinputs: [...this.inputs],\n\t\t\tcommands: [...this.commands],\n\t\t});\n\t}\n\n\tapplyResolvedData(resolved: TransactionData) {\n\t\tif (!this.sender) {\n\t\t\tthis.sender = resolved.sender ?? null;\n\t\t}\n\n\t\tif (!this.expiration) {\n\t\t\tthis.expiration = resolved.expiration ?? null;\n\t\t}\n\n\t\tif (!this.gasData.budget) {\n\t\t\tthis.gasData.budget = resolved.gasData.budget;\n\t\t}\n\n\t\tif (!this.gasData.owner) {\n\t\t\tthis.gasData.owner = resolved.gasData.owner ?? null;\n\t\t}\n\n\t\tif (!this.gasData.payment) {\n\t\t\tthis.gasData.payment = resolved.gasData.payment;\n\t\t}\n\n\t\tif (!this.gasData.price) {\n\t\t\tthis.gasData.price = resolved.gasData.price;\n\t\t}\n\n\t\tfor (let i = 0; i < this.inputs.length; i++) {\n\t\t\tconst input = this.inputs[i];\n\t\t\tconst resolvedInput = resolved.inputs[i];\n\n\t\t\tswitch (input.$kind) {\n\t\t\t\tcase 'UnresolvedPure':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Pure') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to a Pure argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'UnresolvedObject':\n\t\t\t\t\tif (resolvedInput.$kind !== 'Object') {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Expected input at index ${i} to resolve to an Object argument, but got ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'ImmOrOwnedObject' ||\n\t\t\t\t\t\tresolvedInput.Object.$kind === 'Receiving'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved =\n\t\t\t\t\t\t\tresolvedInput.Object.ImmOrOwnedObject ?? resolvedInput.Object.Receiving!;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.version != null && original.version !== resolved.version) ||\n\t\t\t\t\t\t\t(original.digest != null && original.digest !== resolved.digest) ||\n\t\t\t\t\t\t\t// Objects with shared object properties should not resolve to owned objects\n\t\t\t\t\t\t\toriginal.mutable != null ||\n\t\t\t\t\t\t\toriginal.initialSharedVersion != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (resolvedInput.Object.$kind === 'SharedObject') {\n\t\t\t\t\t\tconst original = input.UnresolvedObject;\n\t\t\t\t\t\tconst resolved = resolvedInput.Object.SharedObject;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tnormalizeSuiAddress(original.objectId) !== normalizeSuiAddress(resolved.objectId) ||\n\t\t\t\t\t\t\t(original.initialSharedVersion != null &&\n\t\t\t\t\t\t\t\toriginal.initialSharedVersion !== resolved.initialSharedVersion) ||\n\t\t\t\t\t\t\t(original.mutable != null && original.mutable !== resolved.mutable) ||\n\t\t\t\t\t\t\t// Objects with owned object properties should not resolve to shared objects\n\t\t\t\t\t\t\toriginal.version != null ||\n\t\t\t\t\t\t\toriginal.digest != null\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Input at index ${i} did not match unresolved object. ${JSON.stringify(original)} is not compatible with ${JSON.stringify(resolved)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Input at index ${i} resolved to an unexpected Object kind: ${JSON.stringify(\n\t\t\t\t\t\t\t\tresolvedInput.Object,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.inputs[i] = resolvedInput;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface ClientCacheOptions {\n\tprefix?: string[];\n\tcache?: Map<string, unknown>;\n}\n\nexport class ClientCache {\n\t#prefix: string[];\n\t#cache: Map<string, unknown>;\n\n\tconstructor({ prefix, cache }: ClientCacheOptions = {}) {\n\t\tthis.#prefix = prefix ?? [];\n\t\tthis.#cache = cache ?? new Map();\n\t}\n\n\tread<T>(key: [string, ...string[]], load: () => T | Promise<T>): T | Promise<T> {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\tif (typeof result === 'object' && result !== null && 'then' in result) {\n\t\t\treturn Promise.resolve(result)\n\t\t\t\t.then((v) => {\n\t\t\t\t\tthis.#cache.set(cacheKey, v);\n\t\t\t\t\treturn v as T;\n\t\t\t\t})\n\t\t\t\t.catch((err) => {\n\t\t\t\t\tthis.#cache.delete(cacheKey);\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\t\t}\n\n\t\treturn result as T;\n\t}\n\n\treadSync<T>(key: [string, ...string[]], load: () => T): T {\n\t\tconst cacheKey = [this.#prefix, ...key].join(':');\n\n\t\tif (this.#cache.has(cacheKey)) {\n\t\t\treturn this.#cache.get(cacheKey) as T;\n\t\t}\n\n\t\tconst result = load();\n\n\t\tthis.#cache.set(cacheKey, result);\n\n\t\treturn result as T;\n\t}\n\n\tclear(prefix?: string[]) {\n\t\tconst prefixKey = [...this.#prefix, ...(prefix ?? [])].join(':');\n\t\tif (!prefixKey) {\n\t\t\tthis.#cache.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const key of this.#cache.keys()) {\n\t\t\tif (key.startsWith(prefixKey)) {\n\t\t\t\tthis.#cache.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tscope(prefix: string | string[]) {\n\t\treturn new ClientCache({\n\t\t\tprefix: [...this.#prefix, ...(Array.isArray(prefix) ? prefix : [prefix])],\n\t\t\tcache: this.#cache,\n\t\t});\n\t}\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '1.45.2';\nexport const TARGETED_RPC_VERSION = '1.62.0';\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { chunk, DataLoader } from '@mysten/utils';\nimport { isValidNamedPackage, isValidNamedType } from '../utils/move-registry.js';\nimport type { StructTag } from '../utils/sui-types.js';\nimport {\n\tisValidSuiAddress,\n\tnormalizeStructTag,\n\tnormalizeSuiAddress,\n\tparseStructTag,\n} from '../utils/sui-types.js';\nimport type { ClientCache } from './cache.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { PACKAGE_VERSION } from '../version.js';\nimport type { Experimental_SuiClientTypes } from './types.js';\n\nconst NAME_SEPARATOR = '/';\nconst MVR_API_HEADER = {\n\t'Mvr-Source': `@mysten/sui@${PACKAGE_VERSION}`,\n};\n\nexport interface MvrClientOptions {\n\tcache: ClientCache;\n\turl?: string;\n\tpageSize?: number;\n\toverrides?: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n}\n\nexport class MvrClient implements Experimental_SuiClientTypes.MvrMethods {\n\t#cache: ClientCache;\n\t#url?: string;\n\t#pageSize: number;\n\t#overrides: {\n\t\tpackages?: Record<string, string>;\n\t\ttypes?: Record<string, string>;\n\t};\n\n\tconstructor({ cache, url, pageSize = 50, overrides }: MvrClientOptions) {\n\t\tthis.#cache = cache;\n\t\tthis.#url = url;\n\t\tthis.#pageSize = pageSize;\n\t\tthis.#overrides = {\n\t\t\tpackages: overrides?.packages,\n\t\t\ttypes: overrides?.types,\n\t\t};\n\n\t\tvalidateOverrides(this.#overrides);\n\t}\n\n\tget #mvrPackageDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrPackageDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (packages) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${packages.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolvePackages(packages);\n\n\t\t\t\treturn packages.map(\n\t\t\t\t\t(pkg) => resolved[pkg] ?? new Error(`Failed to resolve package: ${pkg}`),\n\t\t\t\t);\n\t\t\t});\n\t\t\tconst overrides = this.#overrides?.packages;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [pkg, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(pkg, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tget #mvrTypeDataLoader() {\n\t\treturn this.#cache.readSync(['#mvrTypeDataLoader', this.#url ?? ''], () => {\n\t\t\tconst loader = new DataLoader<string, string>(async (types) => {\n\t\t\t\tif (!this.#url) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`MVR Api URL is not set for the current client (resolving ${types.join(', ')})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst resolved = await this.#resolveTypes(types);\n\n\t\t\t\treturn types.map((type) => resolved[type] ?? new Error(`Failed to resolve type: ${type}`));\n\t\t\t});\n\n\t\t\tconst overrides = this.#overrides?.types;\n\n\t\t\tif (overrides) {\n\t\t\t\tfor (const [type, id] of Object.entries(overrides)) {\n\t\t\t\t\tloader.prime(type, id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn loader;\n\t\t});\n\t}\n\n\tasync #resolvePackages(packages: readonly string[]) {\n\t\tif (packages.length === 0) return {};\n\n\t\tconst batches = chunk(packages, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { package_id: string }> }>(\n\t\t\t\t\t'/v1/resolution/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\tnames: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const pkg of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst pkgData = data.resolution[pkg]?.package_id;\n\n\t\t\t\t\tif (!pkgData) continue;\n\n\t\t\t\t\tresults[pkg] = pkgData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #resolveTypes(types: readonly string[]) {\n\t\tif (types.length === 0) return {};\n\n\t\tconst batches = chunk(types, this.#pageSize);\n\t\tconst results: Record<string, string> = {};\n\n\t\tawait Promise.all(\n\t\t\tbatches.map(async (batch) => {\n\t\t\t\tconst data = await this.#fetch<{ resolution: Record<string, { type_tag: string }> }>(\n\t\t\t\t\t'/v1/struct-definition/bulk',\n\t\t\t\t\t{\n\t\t\t\t\t\ttypes: batch,\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tif (!data?.resolution) return;\n\n\t\t\t\tfor (const type of Object.keys(data?.resolution)) {\n\t\t\t\t\tconst typeData = data.resolution[type]?.type_tag;\n\t\t\t\t\tif (!typeData) continue;\n\n\t\t\t\t\tresults[type] = typeData;\n\t\t\t\t}\n\t\t\t}),\n\t\t);\n\n\t\treturn results;\n\t}\n\n\tasync #fetch<T>(url: string, body: Record<string, unknown>): Promise<T> {\n\t\tif (!this.#url) {\n\t\t\tthrow new Error('MVR Api URL is not set for the current client');\n\t\t}\n\n\t\tconst response = await fetch(`${this.#url}${url}`, {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t...MVR_API_HEADER,\n\t\t\t},\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\n\t\tif (!response.ok) {\n\t\t\tconst errorBody = await response.json().catch(() => ({}));\n\t\t\tthrow new Error(`Failed to resolve types: ${errorBody?.message}`);\n\t\t}\n\n\t\treturn response.json();\n\t}\n\n\tasync resolvePackage({\n\t\tpackage: name,\n\t}: Experimental_SuiClientTypes.MvrResolvePackageOptions): Promise<Experimental_SuiClientTypes.MvrResolvePackageResponse> {\n\t\tif (!hasMvrName(name)) {\n\t\t\treturn {\n\t\t\t\tpackage: name,\n\t\t\t};\n\t\t}\n\t\tconst resolved = await this.#mvrPackageDataLoader.load(name);\n\t\treturn {\n\t\t\tpackage: resolved,\n\t\t};\n\t}\n\n\tasync resolveType({\n\t\ttype,\n\t}: Experimental_SuiClientTypes.MvrResolveTypeOptions): Promise<Experimental_SuiClientTypes.MvrResolveTypeResponse> {\n\t\tif (!hasMvrName(type)) {\n\t\t\treturn {\n\t\t\t\ttype,\n\t\t\t};\n\t\t}\n\n\t\tconst mvrTypes = [...extractMvrTypes(type)];\n\t\tconst resolvedTypes = await this.#mvrTypeDataLoader.loadMany(mvrTypes);\n\n\t\tconst typeMap: Record<string, string> = {};\n\n\t\tfor (let i = 0; i < mvrTypes.length; i++) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[mvrTypes[i]] = resolvedType;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: replaceMvrNames(type, typeMap),\n\t\t};\n\t}\n\n\tasync resolve({\n\t\ttypes = [],\n\t\tpackages = [],\n\t}: Experimental_SuiClientTypes.MvrResolveOptions): Promise<Experimental_SuiClientTypes.MvrResolveResponse> {\n\t\tconst mvrTypes = new Set<string>();\n\n\t\tfor (const type of types ?? []) {\n\t\t\textractMvrTypes(type, mvrTypes);\n\t\t}\n\n\t\tconst typesArray = [...mvrTypes];\n\t\tconst [resolvedTypes, resolvedPackages] = await Promise.all([\n\t\t\ttypesArray.length > 0 ? this.#mvrTypeDataLoader.loadMany(typesArray) : [],\n\t\t\tpackages.length > 0 ? this.#mvrPackageDataLoader.loadMany(packages) : [],\n\t\t]);\n\n\t\tconst typeMap: Record<string, string> = {\n\t\t\t...this.#overrides?.types,\n\t\t};\n\n\t\tfor (const [i, type] of typesArray.entries()) {\n\t\t\tconst resolvedType = resolvedTypes[i];\n\t\t\tif (resolvedType instanceof Error) {\n\t\t\t\tthrow resolvedType;\n\t\t\t}\n\t\t\ttypeMap[type] = resolvedType;\n\t\t}\n\n\t\tconst replacedTypes: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\ttype: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const type of types ?? []) {\n\t\t\tconst resolvedType = replaceMvrNames(type, typeMap);\n\n\t\t\treplacedTypes[type] = {\n\t\t\t\ttype: resolvedType,\n\t\t\t};\n\t\t}\n\n\t\tconst replacedPackages: Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tpackage: string;\n\t\t\t}\n\t\t> = {};\n\n\t\tfor (const [i, pkg] of (packages ?? []).entries()) {\n\t\t\tconst resolvedPkg = this.#overrides?.packages?.[pkg] ?? resolvedPackages[i];\n\n\t\t\tif (resolvedPkg instanceof Error) {\n\t\t\t\tthrow resolvedPkg;\n\t\t\t}\n\n\t\t\treplacedPackages[pkg] = {\n\t\t\t\tpackage: resolvedPkg,\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\ttypes: replacedTypes,\n\t\t\tpackages: replacedPackages,\n\t\t};\n\t}\n}\n\nfunction validateOverrides(overrides?: {\n\tpackages?: Record<string, string>;\n\ttypes?: Record<string, string>;\n}) {\n\tif (overrides?.packages) {\n\t\tfor (const [pkg, id] of Object.entries(overrides.packages)) {\n\t\t\tif (!isValidNamedPackage(pkg)) {\n\t\t\t\tthrow new Error(`Invalid package name: ${pkg}`);\n\t\t\t}\n\t\t\tif (!isValidSuiAddress(normalizeSuiAddress(id))) {\n\t\t\t\tthrow new Error(`Invalid package ID: ${id}`);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (overrides?.types) {\n\t\tfor (const [type, val] of Object.entries(overrides.types)) {\n\t\t\t// validate that types are first-level only.\n\t\t\tif (parseStructTag(type).typeParams.length > 0) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst parsedValue = parseStructTag(val);\n\n\t\t\tif (!isValidSuiAddress(parsedValue.address)) {\n\t\t\t\tthrow new Error(`Invalid type: ${val}`);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Extracts all named types from a given type.\n */\nexport function extractMvrTypes(type: string | StructTag, types = new Set<string>()) {\n\tif (typeof type === 'string' && !hasMvrName(type)) return types;\n\n\tconst tag = isStructTag(type) ? type : parseStructTag(type);\n\n\tif (hasMvrName(tag.address)) types.add(`${tag.address}::${tag.module}::${tag.name}`);\n\n\tfor (const param of tag.typeParams) {\n\t\textractMvrTypes(param, types);\n\t}\n\n\treturn types;\n}\n\n/**\n * Traverses a type, and replaces any found names with their resolved equivalents,\n * based on the supplied type cache.\n */\nfunction replaceMvrNames(tag: string | StructTag, typeCache: Record<string, string>): string {\n\tconst type = isStructTag(tag) ? tag : parseStructTag(tag);\n\n\tconst typeTag = `${type.address}::${type.module}::${type.name}`;\n\tconst cacheHit = typeCache[typeTag];\n\n\treturn normalizeStructTag({\n\t\t...type,\n\t\taddress: cacheHit ? cacheHit.split('::')[0] : type.address,\n\t\ttypeParams: type.typeParams.map((param) => replaceMvrNames(param, typeCache)),\n\t});\n}\n\nexport function hasMvrName(nameOrType: string) {\n\treturn (\n\t\tnameOrType.includes(NAME_SEPARATOR) || nameOrType.includes('@') || nameOrType.includes('.sui')\n\t);\n}\n\nfunction isStructTag(type: string | StructTag): type is StructTag {\n\treturn (\n\t\ttypeof type === 'object' &&\n\t\t'address' in type &&\n\t\t'module' in type &&\n\t\t'name' in type &&\n\t\t'typeParams' in type\n\t);\n}\n\nexport type NamedPackagesOverrides = {\n\tpackages: Record<string, string>;\n\ttypes: Record<string, string>;\n};\n\n/**\n * Looks up all `.move` names in a transaction block.\n * Returns a list of all the names found.\n */\nexport function findNamesInTransaction(builder: TransactionDataBuilder): {\n\tpackages: string[];\n\ttypes: string[];\n} {\n\tconst packages: Set<string> = new Set();\n\tconst types: Set<string> = new Set();\n\n\tfor (const command of builder.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'MakeMoveVec':\n\t\t\t\tif (command.MakeMoveVec.type) {\n\t\t\t\t\tgetNamesFromTypeList([command.MakeMoveVec.type]).forEach((type) => {\n\t\t\t\t\t\ttypes.add(type);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'MoveCall':\n\t\t\t\tconst moveCall = command.MoveCall;\n\n\t\t\t\tconst pkg = moveCall.package.split('::')[0];\n\t\t\t\tif (hasMvrName(pkg)) {\n\t\t\t\t\tif (!isValidNamedPackage(pkg)) throw new Error(`Invalid package name: ${pkg}`);\n\t\t\t\t\tpackages.add(pkg);\n\t\t\t\t}\n\n\t\t\t\tgetNamesFromTypeList(moveCall.typeArguments ?? []).forEach((type) => {\n\t\t\t\t\ttypes.add(type);\n\t\t\t\t});\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn {\n\t\tpackages: [...packages],\n\t\ttypes: [...types],\n\t};\n}\n\n/**\n * Replace all names & types in a transaction block\n * with their resolved names/types.\n */\nexport function replaceNames(\n\tbuilder: TransactionDataBuilder,\n\tresolved: Experimental_SuiClientTypes.MvrResolveResponse,\n) {\n\tfor (const command of builder.commands) {\n\t\t// Replacements for `MakeMoveVec` commands (that can include types)\n\t\tif (command.MakeMoveVec?.type) {\n\t\t\tif (!hasMvrName(command.MakeMoveVec.type)) continue;\n\t\t\tif (!resolved.types[command.MakeMoveVec.type])\n\t\t\t\tthrow new Error(`No resolution found for type: ${command.MakeMoveVec.type}`);\n\t\t\tcommand.MakeMoveVec.type = resolved.types[command.MakeMoveVec.type].type;\n\t\t}\n\t\t// Replacements for `MoveCall` commands (that can include packages & types)\n\t\tconst tx = command.MoveCall;\n\t\tif (!tx) continue;\n\n\t\tconst nameParts = tx.package.split('::');\n\t\tconst name = nameParts[0];\n\n\t\tif (hasMvrName(name) && !resolved.packages[name])\n\t\t\tthrow new Error(`No address found for package: ${name}`);\n\n\t\t// Replace package name with address.\n\t\tif (hasMvrName(name)) {\n\t\t\tnameParts[0] = resolved.packages[name].package;\n\t\t\ttx.package = nameParts.join('::');\n\t\t}\n\n\t\tconst types = tx.typeArguments;\n\t\tif (!types) continue;\n\n\t\tfor (let i = 0; i < types.length; i++) {\n\t\t\tif (!hasMvrName(types[i])) continue;\n\n\t\t\tif (!resolved.types[types[i]]) throw new Error(`No resolution found for type: ${types[i]}`);\n\t\t\ttypes[i] = resolved.types[types[i]].type;\n\t\t}\n\n\t\ttx.typeArguments = types;\n\t}\n}\n\n/**\n * Returns a list of unique types that include a name\n * from the given list. This list is retrieved from the Transaction Data.\n */\nfunction getNamesFromTypeList(types: string[]) {\n\tconst names = new Set<string>();\n\tfor (const type of types) {\n\t\tif (hasMvrName(type)) {\n\t\t\tif (!isValidNamedType(type)) throw new Error(`Invalid type with names: ${type}`);\n\t\t\tnames.add(type);\n\t\t}\n\t}\n\treturn names;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ClientCache } from '../../experimental/cache.js';\nimport { MvrClient } from '../../experimental/mvr.js';\nimport type { BuildTransactionOptions } from '../resolve.js';\nimport type { TransactionDataBuilder } from '../TransactionData.js';\nimport { findNamesInTransaction, replaceNames } from '../../experimental/mvr.js';\nimport type { NamedPackagesOverrides } from '../../experimental/mvr.js';\n\nexport type NamedPackagesPluginOptions = {\n\t/**\n\t * The URL of the MVR API to use for resolving names.\n\t */\n\turl: string;\n\t/**\n\t * The number of names to resolve in each batch request.\n\t * Needs to be calculated based on the GraphQL query limits.\n\t */\n\tpageSize?: number;\n\t/**\n\t * Local overrides for the resolution plugin. Pass this to pre-populate\n\t * the cache with known packages / types (especially useful for local or CI testing).\n\t *\n\t * The type cache expects ONLY first-level types to ensure the cache is more composable.\n\t *\n\t * \tExpected format example:\n\t *  {\n\t * \t\tpackages: {\n\t * \t\t\t'@framework/std': '0x1234',\n\t * \t\t},\n\t * \t\ttypes: {\n\t * \t\t\t'@framework/std::string::String': '0x1234::string::String',\n\t * \t\t},\n\t * \t}\n\t *\n\t */\n\toverrides?: NamedPackagesOverrides;\n};\n\n// The original versions of the mvr plugin cached lookups by mutating overrides.\n// We don't want to mutate the options, but we can link our cache to the provided overrides object\n// This preserves the caching across transactions while removing the mutation side effects\nconst cacheMap = new WeakMap<object, ClientCache>();\n\n/**\n * @experimental This plugin is in experimental phase and there might be breaking changes in the future\n *\n * Adds named resolution so that you can use .move names in your transactions.\n * e.g. `@org/app::type::Type` will be resolved to `0x1234::type::Type`.\n * This plugin will resolve all names & types in the transaction block.\n *\n * To install this plugin globally in your app, use:\n * ```\n * Transaction.registerGlobalSerializationPlugin(\"namedPackagesPlugin\", namedPackagesPlugin({ suiGraphQLClient }));\n * ```\n *\n * You can also define `overrides` to pre-populate name resolutions locally (removes the GraphQL request).\n */\nexport const namedPackagesPlugin = (options?: NamedPackagesPluginOptions) => {\n\tlet mvrClient: MvrClient | undefined;\n\n\tif (options) {\n\t\tconst overrides = options.overrides ?? {\n\t\t\tpackages: {},\n\t\t\ttypes: {},\n\t\t};\n\n\t\tif (!cacheMap.has(overrides)) {\n\t\t\tcacheMap.set(overrides, new ClientCache());\n\t\t}\n\n\t\tmvrClient = new MvrClient({\n\t\t\tcache: cacheMap.get(overrides)!,\n\t\t\turl: options.url,\n\t\t\tpageSize: options.pageSize,\n\t\t\toverrides: overrides,\n\t\t});\n\t}\n\n\treturn async (\n\t\ttransactionData: TransactionDataBuilder,\n\t\tbuildOptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) => {\n\t\tconst names = findNamesInTransaction(transactionData);\n\n\t\tif (names.types.length === 0 && names.packages.length === 0) {\n\t\t\treturn next();\n\t\t}\n\n\t\tconst resolved = await (mvrClient || getClient(buildOptions).core.mvr).resolve({\n\t\t\ttypes: names.types,\n\t\t\tpackages: names.packages,\n\t\t});\n\n\t\treplaceNames(transactionData, resolved);\n\n\t\tawait next();\n\t};\n};\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { EnumInputShape } from '@mysten/bcs';\nimport type { GenericSchema, InferInput, InferOutput } from 'valibot';\nimport {\n\tarray,\n\tboolean,\n\tinteger,\n\tliteral,\n\tnullable,\n\tnullish,\n\tnumber,\n\tobject,\n\toptional,\n\tpipe,\n\trecord,\n\tstring,\n\ttuple,\n\tunion,\n\tunknown,\n} from 'valibot';\n\nimport { BCSBytes, JsonU64, ObjectID, ObjectRefSchema, SuiAddress } from './internal.js';\nimport type { Simplify } from '@mysten/utils';\n\nfunction enumUnion<T extends Record<string, GenericSchema<any>>>(options: T) {\n\treturn union(\n\t\tObject.entries(options).map(([key, value]) => object({ [key]: value })),\n\t) as GenericSchema<\n\t\tEnumInputShape<\n\t\t\tSimplify<{\n\t\t\t\t[K in keyof T]: InferInput<T[K]>;\n\t\t\t}>\n\t\t>\n\t>;\n}\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L690-L702\nconst Argument = enumUnion({\n\tGasCoin: literal(true),\n\tInput: pipe(number(), integer()),\n\tResult: pipe(number(), integer()),\n\tNestedResult: tuple([pipe(number(), integer()), pipe(number(), integer())]),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L1387-L1392\nconst GasData = object({\n\tbudget: nullable(JsonU64),\n\tprice: nullable(JsonU64),\n\towner: nullable(SuiAddress),\n\tpayment: nullable(array(ObjectRefSchema)),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L707-L718\nconst ProgrammableMoveCall = object({\n\tpackage: ObjectID,\n\tmodule: string(),\n\tfunction: string(),\n\t// snake case in rust\n\ttypeArguments: array(string()),\n\targuments: array(Argument),\n});\n\nconst $Intent = object({\n\tname: string(),\n\tinputs: record(string(), union([Argument, array(Argument)])),\n\tdata: record(string(), unknown()),\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L657-L685\nconst Command = enumUnion({\n\tMoveCall: ProgrammableMoveCall,\n\tTransferObjects: object({\n\t\tobjects: array(Argument),\n\t\taddress: Argument,\n\t}),\n\tSplitCoins: object({\n\t\tcoin: Argument,\n\t\tamounts: array(Argument),\n\t}),\n\tMergeCoins: object({\n\t\tdestination: Argument,\n\t\tsources: array(Argument),\n\t}),\n\tPublish: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t}),\n\tMakeMoveVec: object({\n\t\ttype: nullable(string()),\n\t\telements: array(Argument),\n\t}),\n\tUpgrade: object({\n\t\tmodules: array(BCSBytes),\n\t\tdependencies: array(ObjectID),\n\t\tpackage: ObjectID,\n\t\tticket: Argument,\n\t}),\n\t$Intent,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L102-L114\nconst ObjectArg = enumUnion({\n\tImmOrOwnedObject: ObjectRefSchema,\n\tSharedObject: object({\n\t\tobjectId: ObjectID,\n\t\t// snake case in rust\n\t\tinitialSharedVersion: JsonU64,\n\t\tmutable: boolean(),\n\t}),\n\tReceiving: ObjectRefSchema,\n});\n\n// https://github.com/MystenLabs/sui/blob/df41d5fa8127634ff4285671a01ead00e519f806/crates/sui-types/src/transaction.rs#L75-L80\nconst CallArg = enumUnion({\n\tObject: ObjectArg,\n\tPure: object({\n\t\tbytes: BCSBytes,\n\t}),\n\tUnresolvedPure: object({\n\t\tvalue: unknown(),\n\t}),\n\tUnresolvedObject: object({\n\t\tobjectId: ObjectID,\n\t\tversion: optional(nullable(JsonU64)),\n\t\tdigest: optional(nullable(string())),\n\t\tinitialSharedVersion: optional(nullable(JsonU64)),\n\t\tmutable: optional(nullable(boolean())),\n\t}),\n});\n\nconst TransactionExpiration = enumUnion({\n\tNone: literal(true),\n\tEpoch: JsonU64,\n});\n\nexport const SerializedTransactionDataV2Schema = object({\n\tversion: literal(2),\n\tsender: nullish(SuiAddress),\n\texpiration: nullish(TransactionExpiration),\n\tgasData: GasData,\n\tinputs: array(CallArg),\n\tcommands: array(Command),\n\tdigest: optional(nullable(string())),\n});\n\nexport type SerializedTransactionDataV2 = InferOutput<typeof SerializedTransactionDataV2Schema>;\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parse } from 'valibot';\n\nimport { normalizeSuiAddress, normalizeSuiObjectId, SUI_TYPE_ARG } from '../utils/index.js';\nimport { ObjectRefSchema } from '../transactions/data/internal.js';\nimport type { CallArg, Command, OpenMoveTypeSignature } from '../transactions/data/internal.js';\nimport { Inputs } from '../transactions/Inputs.js';\nimport {\n\tgetPureBcsSchema,\n\tisTxContext,\n\tnormalizedTypeToMoveTypeSignature,\n} from '../transactions/serializer.js';\nimport type { TransactionDataBuilder } from '../transactions/TransactionData.js';\nimport { chunk } from '@mysten/utils';\nimport type { BuildTransactionOptions } from '../transactions/index.js';\nimport type { SuiJsonRpcClient } from './client.js';\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_GAS = 50_000_000_000;\n\nexport function jsonRpcClientResolveTransactionPlugin(client: SuiJsonRpcClient) {\n\treturn async function resolveTransactionData(\n\t\ttransactionData: TransactionDataBuilder,\n\t\toptions: BuildTransactionOptions,\n\t\tnext: () => Promise<void>,\n\t) {\n\t\tawait normalizeInputs(transactionData, client);\n\t\tawait resolveObjectReferences(transactionData, client);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait setGasPrice(transactionData, client);\n\t\t\tawait setGasBudget(transactionData, client);\n\t\t\tawait setGasPayment(transactionData, client);\n\t\t}\n\n\t\treturn await next();\n\t};\n}\n\nasync function setGasPrice(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.price) {\n\t\ttransactionData.gasConfig.price = String(await client.getReferenceGasPrice());\n\t}\n}\n\nasync function setGasBudget(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (transactionData.gasConfig.budget) {\n\t\treturn;\n\t}\n\n\tconst dryRunResult = await client.dryRunTransactionBlock({\n\t\ttransactionBlock: transactionData.build({\n\t\t\toverrides: {\n\t\t\t\tgasData: {\n\t\t\t\t\tbudget: String(MAX_GAS),\n\t\t\t\t\tpayment: [],\n\t\t\t\t},\n\t\t\t},\n\t\t}),\n\t});\n\n\tif (dryRunResult.effects.status.status !== 'success') {\n\t\tthrow new Error(\n\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t{ cause: dryRunResult },\n\t\t);\n\t}\n\n\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(transactionData.gasConfig.price || 1n);\n\n\tconst baseComputationCostWithOverhead =\n\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\tconst gasBudget =\n\t\tbaseComputationCostWithOverhead +\n\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\ttransactionData.gasConfig.budget = String(\n\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t);\n}\n\n// The current default is just picking _all_ coins we can which may not be ideal.\nasync function setGasPayment(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tif (!transactionData.gasConfig.payment) {\n\t\tconst coins = await client.getCoins({\n\t\t\towner: transactionData.gasConfig.owner || transactionData.sender!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = transactionData.inputs.find((input) => {\n\t\t\t\t\tif (input.Object?.ImmOrOwnedObject) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.Object.ImmOrOwnedObject.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\ttransactionData.gasConfig.payment = paymentCoins.map((payment) =>\n\t\t\tparse(ObjectRefSchema, payment),\n\t\t);\n\t}\n}\n\nasync function resolveObjectReferences(\n\ttransactionData: TransactionDataBuilder,\n\tclient: SuiJsonRpcClient,\n) {\n\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t// We keep the input by-reference to avoid needing to re-resolve it:\n\tconst objectsToResolve = transactionData.inputs.filter((input) => {\n\t\treturn (\n\t\t\tinput.UnresolvedObject &&\n\t\t\t!(input.UnresolvedObject.version || input.UnresolvedObject?.initialSharedVersion)\n\t\t);\n\t}) as Extract<CallArg, { UnresolvedObject: unknown }>[];\n\n\tconst dedupedIds = [\n\t\t...new Set(\n\t\t\tobjectsToResolve.map((input) => normalizeSuiObjectId(input.UnresolvedObject.objectId)),\n\t\t),\n\t];\n\n\tconst objectChunks = dedupedIds.length ? chunk(dedupedIds, MAX_OBJECTS_PER_FETCH) : [];\n\tconst resolved = (\n\t\tawait Promise.all(\n\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\tclient.multiGetObjects({\n\t\t\t\t\tids: chunk,\n\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t).flat();\n\n\tconst responsesById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, resolved[index]];\n\t\t}),\n\t);\n\n\tconst invalidObjects = Array.from(responsesById)\n\t\t.filter(([_, obj]) => obj.error)\n\t\t.map(([_, obj]) => JSON.stringify(obj.error));\n\n\tif (invalidObjects.length) {\n\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t}\n\n\tconst objects = resolved.map((object) => {\n\t\tif (object.error || !object.data) {\n\t\t\tthrow new Error(`Failed to fetch object: ${object.error}`);\n\t\t}\n\t\tconst owner = object.data.owner;\n\t\tconst initialSharedVersion =\n\t\t\towner && typeof owner === 'object'\n\t\t\t\t? 'Shared' in owner\n\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t: 'ConsensusAddressOwner' in owner\n\t\t\t\t\t\t? owner.ConsensusAddressOwner.start_version\n\t\t\t\t\t\t: null\n\t\t\t\t: null;\n\n\t\treturn {\n\t\t\tobjectId: object.data.objectId,\n\t\t\tdigest: object.data.digest,\n\t\t\tversion: object.data.version,\n\t\t\tinitialSharedVersion,\n\t\t};\n\t});\n\n\tconst objectsById = new Map(\n\t\tdedupedIds.map((id, index) => {\n\t\t\treturn [id, objects[index]];\n\t\t}),\n\t);\n\n\tfor (const [index, input] of transactionData.inputs.entries()) {\n\t\tif (!input.UnresolvedObject) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet updated: CallArg | undefined;\n\t\tconst id = normalizeSuiAddress(input.UnresolvedObject.objectId);\n\t\tconst object = objectsById.get(id);\n\n\t\tif (input.UnresolvedObject.initialSharedVersion ?? object?.initialSharedVersion) {\n\t\t\tupdated = Inputs.SharedObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tinitialSharedVersion:\n\t\t\t\t\tinput.UnresolvedObject.initialSharedVersion || object?.initialSharedVersion!,\n\t\t\t\tmutable: input.UnresolvedObject.mutable || isUsedAsMutable(transactionData, index),\n\t\t\t});\n\t\t} else if (isUsedAsReceiving(transactionData, index)) {\n\t\t\tupdated = Inputs.ReceivingRef(\n\t\t\t\t{\n\t\t\t\t\tobjectId: id,\n\t\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t\t}!,\n\t\t\t);\n\t\t}\n\n\t\ttransactionData.inputs[transactionData.inputs.indexOf(input)] =\n\t\t\tupdated ??\n\t\t\tInputs.ObjectRef({\n\t\t\t\tobjectId: id,\n\t\t\t\tdigest: input.UnresolvedObject.digest ?? object?.digest!,\n\t\t\t\tversion: input.UnresolvedObject.version ?? object?.version!,\n\t\t\t});\n\t}\n}\n\nasync function normalizeInputs(transactionData: TransactionDataBuilder, client: SuiJsonRpcClient) {\n\tconst { inputs, commands } = transactionData;\n\tconst moveCallsToResolve: Extract<Command, { MoveCall: unknown }>['MoveCall'][] = [];\n\tconst moveFunctionsToResolve = new Set<string>();\n\n\tcommands.forEach((command) => {\n\t\t// Special case move call:\n\t\tif (command.MoveCall) {\n\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t// - If they don't, then this is good to go.\n\t\t\t// - If they do, then we need to fetch the normalized move module.\n\n\t\t\t// If we already know the argument types, we don't need to resolve them again\n\t\t\tif (command.MoveCall._argumentTypes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputs = command.MoveCall.arguments.map((arg) => {\n\t\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\t\treturn transactionData.inputs[arg.Input];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\t\t\tconst needsResolution = inputs.some(\n\t\t\t\t(input) =>\n\t\t\t\t\tinput?.UnresolvedPure ||\n\t\t\t\t\t(input?.UnresolvedObject && typeof input?.UnresolvedObject.mutable !== 'boolean'),\n\t\t\t);\n\n\t\t\tif (needsResolution) {\n\t\t\t\tconst functionName = `${command.MoveCall.package}::${command.MoveCall.module}::${command.MoveCall.function}`;\n\t\t\t\tmoveFunctionsToResolve.add(functionName);\n\t\t\t\tmoveCallsToResolve.push(command.MoveCall);\n\t\t\t}\n\t\t}\n\t});\n\n\tconst moveFunctionParameters = new Map<string, OpenMoveTypeSignature[]>();\n\tif (moveFunctionsToResolve.size > 0) {\n\t\tawait Promise.all(\n\t\t\t[...moveFunctionsToResolve].map(async (functionName) => {\n\t\t\t\tconst [packageId, moduleId, functionId] = functionName.split('::');\n\t\t\t\tconst def = await client.getNormalizedMoveFunction({\n\t\t\t\t\tpackage: packageId,\n\t\t\t\t\tmodule: moduleId,\n\t\t\t\t\tfunction: functionId,\n\t\t\t\t});\n\n\t\t\t\tmoveFunctionParameters.set(\n\t\t\t\t\tfunctionName,\n\t\t\t\t\tdef.parameters.map((param) => normalizedTypeToMoveTypeSignature(param)),\n\t\t\t\t);\n\t\t\t}),\n\t\t);\n\t}\n\n\tif (moveCallsToResolve.length) {\n\t\tawait Promise.all(\n\t\t\tmoveCallsToResolve.map(async (moveCall) => {\n\t\t\t\tconst parameters = moveFunctionParameters.get(\n\t\t\t\t\t`${moveCall.package}::${moveCall.module}::${moveCall.function}`,\n\t\t\t\t);\n\n\t\t\t\tif (!parameters) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\tconst hasTxContext = parameters.length > 0 && isTxContext(parameters.at(-1)!);\n\t\t\t\tconst params = hasTxContext ? parameters.slice(0, parameters.length - 1) : parameters;\n\n\t\t\t\tmoveCall._argumentTypes = params;\n\t\t\t}),\n\t\t);\n\t}\n\n\tcommands.forEach((command) => {\n\t\tif (!command.MoveCall) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst moveCall = command.MoveCall;\n\t\tconst fnName = `${moveCall.package}::${moveCall.module}::${moveCall.function}`;\n\t\tconst params = moveCall._argumentTypes;\n\n\t\tif (!params) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (params.length !== command.MoveCall.arguments.length) {\n\t\t\tthrow new Error(`Incorrect number of arguments for ${fnName}`);\n\t\t}\n\n\t\tparams.forEach((param, i) => {\n\t\t\tconst arg = moveCall.arguments[i];\n\t\t\tif (arg.$kind !== 'Input') return;\n\t\t\tconst input = inputs[arg.Input];\n\n\t\t\t// Skip if the input is already resolved\n\t\t\tif (!input.UnresolvedPure && !input.UnresolvedObject) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst inputValue = input.UnresolvedPure?.value ?? input.UnresolvedObject?.objectId!;\n\n\t\t\tconst schema = getPureBcsSchema(param.body);\n\t\t\tif (schema) {\n\t\t\t\targ.type = 'pure';\n\t\t\t\tinputs[inputs.indexOf(input)] = Inputs.Pure(schema.serialize(inputValue));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t2,\n\t\t\t\t\t)}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\targ.type = 'object';\n\t\t\tconst unresolvedObject: typeof input = input.UnresolvedPure\n\t\t\t\t? {\n\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\tUnresolvedObject: {\n\t\t\t\t\t\t\tobjectId: inputValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: input;\n\n\t\t\tinputs[arg.Input] = unresolvedObject;\n\t\t});\n\t});\n}\n\nfunction isUsedAsMutable(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsMutable = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsMutable = tx.MoveCall._argumentTypes[argIndex].ref !== '&' || usedAsMutable;\n\t\t}\n\n\t\tif (\n\t\t\ttx.$kind === 'MakeMoveVec' ||\n\t\t\ttx.$kind === 'MergeCoins' ||\n\t\t\ttx.$kind === 'SplitCoins' ||\n\t\t\ttx.$kind === 'TransferObjects'\n\t\t) {\n\t\t\tusedAsMutable = true;\n\t\t}\n\t});\n\n\treturn usedAsMutable;\n}\n\nfunction isUsedAsReceiving(transactionData: TransactionDataBuilder, index: number) {\n\tlet usedAsReceiving = false;\n\n\ttransactionData.getInputUses(index, (arg, tx) => {\n\t\tif (tx.MoveCall && tx.MoveCall._argumentTypes) {\n\t\t\tconst argIndex = tx.MoveCall.arguments.indexOf(arg);\n\t\t\tusedAsReceiving = isReceivingType(tx.MoveCall._argumentTypes[argIndex]) || usedAsReceiving;\n\t\t}\n\t});\n\n\treturn usedAsReceiving;\n}\n\nfunction isReceivingType(type: OpenMoveTypeSignature): boolean {\n\tif (typeof type.body !== 'object' || !('datatype' in type.body)) {\n\t\treturn false;\n\t}\n\n\treturn (\n\t\ttype.body.datatype.package === '0x2' &&\n\t\ttype.body.datatype.module === 'transfer' &&\n\t\ttype.body.datatype.type === 'Receiving'\n\t);\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Argument } from './data/internal.js';\n\nimport type { ClientWithCoreApi } from '../experimental/index.js';\nimport type { TransactionDataBuilder } from './TransactionData.js';\nimport type { BcsType } from '@mysten/bcs';\nimport { Inputs } from './Inputs.js';\nimport { bcs } from '../bcs/index.js';\nimport { jsonRpcClientResolveTransactionPlugin } from '../jsonRpc/json-rpc-resolver.js';\nimport type { SuiJsonRpcClient } from '../jsonRpc/client.js';\n\nexport interface BuildTransactionOptions {\n\tclient?: ClientWithCoreApi;\n\tonlyTransactionKind?: boolean;\n}\n\nexport interface SerializeTransactionOptions extends BuildTransactionOptions {\n\tsupportedIntents?: string[];\n}\n\nexport type TransactionPlugin = (\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) => Promise<void>;\n\nexport function needsTransactionResolution(\n\tdata: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n): boolean {\n\tif (\n\t\tdata.inputs.some((input) => {\n\t\t\treturn input.UnresolvedObject || input.UnresolvedPure;\n\t\t})\n\t) {\n\t\treturn true;\n\t}\n\n\tif (!options.onlyTransactionKind) {\n\t\tif (!data.gasConfig.price || !data.gasConfig.budget || !data.gasConfig.payment) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nexport async function resolveTransactionPlugin(\n\ttransactionData: TransactionDataBuilder,\n\toptions: BuildTransactionOptions,\n\tnext: () => Promise<void>,\n) {\n\tnormalizeRawArguments(transactionData);\n\tif (!needsTransactionResolution(transactionData, options)) {\n\t\tawait validate(transactionData);\n\t\treturn next();\n\t}\n\n\tconst client = getClient(options);\n\tconst plugin =\n\t\tclient.core?.resolveTransactionPlugin() ??\n\t\tjsonRpcClientResolveTransactionPlugin(client as SuiJsonRpcClient);\n\n\treturn plugin(transactionData, options, async () => {\n\t\tawait validate(transactionData);\n\t\tawait next();\n\t});\n}\n\nfunction validate(transactionData: TransactionDataBuilder) {\n\ttransactionData.inputs.forEach((input, index) => {\n\t\tif (input.$kind !== 'Object' && input.$kind !== 'Pure') {\n\t\t\tthrow new Error(\n\t\t\t\t`Input at index ${index} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(\n\t\t\t\t\tinput,\n\t\t\t\t)}`,\n\t\t\t);\n\t\t}\n\t});\n}\n\nexport function getClient(options: BuildTransactionOptions) {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nfunction normalizeRawArguments(transactionData: TransactionDataBuilder) {\n\tfor (const command of transactionData.commands) {\n\t\tswitch (command.$kind) {\n\t\t\tcase 'SplitCoins':\n\t\t\t\tcommand.SplitCoins.amounts.forEach((amount) => {\n\t\t\t\t\tnormalizeRawArgument(amount, bcs.U64, transactionData);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'TransferObjects':\n\t\t\t\tnormalizeRawArgument(command.TransferObjects.address, bcs.Address, transactionData);\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction normalizeRawArgument(\n\targ: Argument,\n\tschema: BcsType<any>,\n\ttransactionData: TransactionDataBuilder,\n) {\n\tif (arg.$kind !== 'Input') {\n\t\treturn;\n\t}\n\tconst input = transactionData.inputs[arg.Input];\n\n\tif (input.$kind !== 'UnresolvedPure') {\n\t\treturn;\n\t}\n\n\ttransactionData.inputs[arg.Input] = Inputs.Pure(schema.serialize(input.UnresolvedPure.value));\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Transaction, TransactionObjectInput } from './Transaction.js';\nimport { Inputs } from './Inputs.js';\n\nexport function createObjectMethods<T>(makeObject: (value: TransactionObjectInput) => T) {\n\tfunction object(value: TransactionObjectInput) {\n\t\treturn makeObject(value);\n\t}\n\n\tobject.system = (options?: { mutable?: boolean }) => {\n\t\tconst mutable = options?.mutable;\n\n\t\tif (mutable !== undefined) {\n\t\t\treturn object(\n\t\t\t\tInputs.SharedObjectRef({\n\t\t\t\t\tobjectId: '0x5',\n\t\t\t\t\tinitialSharedVersion: 1,\n\t\t\t\t\tmutable,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn object({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x5',\n\t\t\t\tinitialSharedVersion: 1,\n\t\t\t},\n\t\t});\n\t};\n\tobject.clock = () =>\n\t\tobject(\n\t\t\tInputs.SharedObjectRef({\n\t\t\t\tobjectId: '0x6',\n\t\t\t\tinitialSharedVersion: 1,\n\t\t\t\tmutable: false,\n\t\t\t}),\n\t\t);\n\tobject.random = () =>\n\t\tobject({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x8',\n\t\t\t\tmutable: false,\n\t\t\t},\n\t\t});\n\tobject.denyList = (options?: { mutable?: boolean }) => {\n\t\treturn object({\n\t\t\t$kind: 'UnresolvedObject',\n\t\t\tUnresolvedObject: {\n\t\t\t\tobjectId: '0x403',\n\t\t\t\tmutable: options?.mutable,\n\t\t\t},\n\t\t});\n\t};\n\tobject.option =\n\t\t({ type, value }: { type: string; value: TransactionObjectInput | null }) =>\n\t\t(tx: Transaction) =>\n\t\t\ttx.moveCall({\n\t\t\t\ttypeArguments: [type],\n\t\t\t\ttarget: `0x1::option::${value === null ? 'none' : 'some'}`,\n\t\t\t\targuments: value === null ? [] : [tx.object(value)],\n\t\t\t});\n\n\treturn object;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { isSerializedBcs } from '@mysten/bcs';\nimport type { SerializedBcs } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport { pureBcsSchemaFromTypeName } from '../bcs/pure.js';\nimport type { PureTypeName, ShapeFromPureTypeName, ValidPureTypeName } from '../bcs/pure.js';\n\nexport function createPure<T>(makePure: (value: SerializedBcs<any, any> | Uint8Array) => T) {\n\tfunction pure<Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type>,\n\t): T;\n\n\tfunction pure(\n\t\t/**\n\t\t * The pure value, serialized to BCS. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: SerializedBcs<any, any> | Uint8Array,\n\t): T;\n\n\tfunction pure(\n\t\ttypeOrSerializedValue?: PureTypeName | SerializedBcs<any, any> | Uint8Array,\n\t\tvalue?: unknown,\n\t): T {\n\t\tif (typeof typeOrSerializedValue === 'string') {\n\t\t\treturn makePure(pureBcsSchemaFromTypeName(typeOrSerializedValue).serialize(value as never));\n\t\t}\n\n\t\tif (typeOrSerializedValue instanceof Uint8Array || isSerializedBcs(typeOrSerializedValue)) {\n\t\t\treturn makePure(typeOrSerializedValue);\n\t\t}\n\n\t\tthrow new Error('tx.pure must be called either a bcs type name, or a serialized bcs value');\n\t}\n\n\tpure.u8 = (value: number) => makePure(bcs.U8.serialize(value));\n\tpure.u16 = (value: number) => makePure(bcs.U16.serialize(value));\n\tpure.u32 = (value: number) => makePure(bcs.U32.serialize(value));\n\tpure.u64 = (value: bigint | number | string) => makePure(bcs.U64.serialize(value));\n\tpure.u128 = (value: bigint | number | string) => makePure(bcs.U128.serialize(value));\n\tpure.u256 = (value: bigint | number | string) => makePure(bcs.U256.serialize(value));\n\tpure.bool = (value: boolean) => makePure(bcs.Bool.serialize(value));\n\tpure.string = (value: string) => makePure(bcs.String.serialize(value));\n\tpure.address = (value: string) => makePure(bcs.Address.serialize(value));\n\tpure.id = pure.address;\n\tpure.vector = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: Iterable<ShapeFromPureTypeName<Type>> & { length: number },\n\t) => {\n\t\treturn makePure(\n\t\t\tbcs.vector(pureBcsSchemaFromTypeName(type as PureTypeName)).serialize(value as never),\n\t\t);\n\t};\n\tpure.option = <Type extends PureTypeName>(\n\t\ttype: Type extends PureTypeName ? ValidPureTypeName<Type> : Type,\n\t\tvalue: ShapeFromPureTypeName<Type> | null | undefined,\n\t) => {\n\t\treturn makePure(bcs.option(pureBcsSchemaFromTypeName(type)).serialize(value as never));\n\t};\n\n\treturn pure;\n}\n", "// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromBase64, isSerializedBcs } from '@mysten/bcs';\nimport type { InferInput } from 'valibot';\nimport { is, parse } from 'valibot';\n\nimport type { SignatureWithBytes, Signer } from '../cryptography/index.js';\nimport { normalizeSuiAddress } from '../utils/sui-types.js';\nimport type { TransactionArgument } from './Commands.js';\nimport { Commands } from './Commands.js';\nimport type { CallArg, Command, Argument, ObjectRef } from './data/internal.js';\nimport {\n\tArgumentSchema,\n\tNormalizedCallArg,\n\tObjectRefSchema,\n\tTransactionExpiration,\n} from './data/internal.js';\nimport { serializeV1TransactionData } from './data/v1.js';\nimport { SerializedTransactionDataV2Schema } from './data/v2.js';\nimport { Inputs } from './Inputs.js';\nimport { needsTransactionResolution, resolveTransactionPlugin } from './resolve.js';\nimport type {\n\tBuildTransactionOptions,\n\tSerializeTransactionOptions,\n\tTransactionPlugin,\n} from './resolve.js';\nimport { createObjectMethods } from './object.js';\nimport { createPure } from './pure.js';\nimport { TransactionDataBuilder } from './TransactionData.js';\nimport { getIdFromCallArg } from './utils.js';\nimport { namedPackagesPlugin } from './plugins/NamedPackagesPlugin.js';\nimport type { ClientWithCoreApi } from '../experimental/core.js';\n\nexport type TransactionObjectArgument =\n\t| Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>\n\t| ((\n\t\t\ttx: Transaction,\n\t  ) => Exclude<InferInput<typeof ArgumentSchema>, { Input: unknown; type?: 'pure' }>)\n\t| AsyncTransactionThunk<TransactionResultArgument>;\n\nexport type TransactionResult = Extract<Argument, { Result: unknown }> &\n\tExtract<Argument, { NestedResult: unknown }>[];\n\nexport type TransactionResultArgument =\n\t| Extract<Argument, { Result: unknown }>\n\t| readonly Extract<Argument, { NestedResult: unknown }>[];\n\nexport type AsyncTransactionThunk<\n\tT extends TransactionResultArgument | void = TransactionResultArgument | void,\n> = (tx: Transaction) => Promise<T | void>;\n\nfunction createTransactionResult(\n\tindex: number | (() => number),\n\tlength = Infinity,\n): TransactionResult {\n\tconst baseResult = {\n\t\t$kind: 'Result' as const,\n\t\tget Result() {\n\t\t\treturn typeof index === 'function' ? index() : index;\n\t\t},\n\t};\n\n\tconst nestedResults: {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t}[] = [];\n\tconst nestedResultFor = (\n\t\tresultIndex: number,\n\t): {\n\t\t$kind: 'NestedResult';\n\t\tNestedResult: [number, number];\n\t} =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\t$kind: 'NestedResult' as const,\n\t\t\tget NestedResult() {\n\t\t\t\treturn [typeof index === 'function' ? index() : index, resultIndex] as [number, number];\n\t\t\t},\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (i < length) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction') as never;\n\ninterface SignOptions extends BuildTransactionOptions {\n\tsigner: Signer;\n}\n\nexport function isTransaction(obj: unknown): obj is TransactionLike {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | CallArg | TransactionObjectArgument;\n\ninterface TransactionPluginRegistry {\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tbuildPlugins: Map<string | Function, TransactionPlugin>;\n\t// eslint-disable-next-line @typescript-eslint/ban-types\n\tserializationPlugins: Map<string | Function, TransactionPlugin>;\n}\n\nconst modulePluginRegistry: TransactionPluginRegistry = {\n\tbuildPlugins: new Map(),\n\tserializationPlugins: new Map(),\n};\n\nconst TRANSACTION_REGISTRY_KEY = Symbol.for('@mysten/transaction/registry');\nfunction getGlobalPluginRegistry() {\n\ttry {\n\t\tconst target = globalThis as {\n\t\t\t[TRANSACTION_REGISTRY_KEY]?: TransactionPluginRegistry;\n\t\t};\n\n\t\tif (!target[TRANSACTION_REGISTRY_KEY]) {\n\t\t\ttarget[TRANSACTION_REGISTRY_KEY] = modulePluginRegistry;\n\t\t}\n\n\t\treturn target[TRANSACTION_REGISTRY_KEY];\n\t} catch {\n\t\treturn modulePluginRegistry;\n\t}\n}\n\ntype InputSection = (CallArg | InputSection)[];\ntype CommandSection = (Command | CommandSection)[];\n\ntype TransactionLike = {\n\tgetData(): unknown;\n};\n\n/**\n * Transaction Builder\n */\nexport class Transaction {\n\t#serializationPlugins: TransactionPlugin[];\n\t#buildPlugins: TransactionPlugin[];\n\t#intentResolvers = new Map<string, TransactionPlugin>();\n\t#inputSection: InputSection = [];\n\t#commandSection: CommandSection = [];\n\t#availableResults: Set<number> = new Set();\n\t#pendingPromises = new Set<Promise<unknown>>();\n\t#added = new Map<(...args: any[]) => unknown, unknown>();\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new Transaction();\n\n\t\ttx.#data = TransactionDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromBase64(serialized) : serialized,\n\t\t);\n\n\t\ttx.#inputSection = tx.#data.inputs.slice();\n\t\ttx.#commandSection = tx.#data.commands.slice();\n\t\ttx.#availableResults = new Set(tx.#commandSection.map((_, i) => i));\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(transaction: string | Uint8Array | TransactionLike) {\n\t\tconst newTransaction = new Transaction();\n\n\t\tif (isTransaction(transaction)) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(\n\t\t\t\ttransaction.getData() as InferInput<typeof SerializedTransactionDataV2Schema>,\n\t\t\t);\n\t\t} else if (typeof transaction !== 'string' || !transaction.startsWith('{')) {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.fromBytes(\n\t\t\t\ttypeof transaction === 'string' ? fromBase64(transaction) : transaction,\n\t\t\t);\n\t\t} else {\n\t\t\tnewTransaction.#data = TransactionDataBuilder.restore(JSON.parse(transaction));\n\t\t}\n\n\t\tnewTransaction.#inputSection = newTransaction.#data.inputs.slice();\n\t\tnewTransaction.#commandSection = newTransaction.#data.commands.slice();\n\t\tnewTransaction.#availableResults = new Set(newTransaction.#commandSection.map((_, i) => i));\n\n\t\treturn newTransaction;\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalSerializationPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalSerializationPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalSerializationPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().serializationPlugins.delete(name);\n\t}\n\n\t/** @deprecated global plugins should be registered with a name */\n\tstatic registerGlobalBuildPlugin(step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(name: string, step: TransactionPlugin): void;\n\tstatic registerGlobalBuildPlugin(\n\t\tstepOrStep: TransactionPlugin | string,\n\t\tstep?: TransactionPlugin,\n\t) {\n\t\tgetGlobalPluginRegistry().buildPlugins.set(\n\t\t\tstepOrStep,\n\t\t\tstep ?? (stepOrStep as TransactionPlugin),\n\t\t);\n\t}\n\n\tstatic unregisterGlobalBuildPlugin(name: string) {\n\t\tgetGlobalPluginRegistry().buildPlugins.delete(name);\n\t}\n\n\taddSerializationPlugin(step: TransactionPlugin) {\n\t\tthis.#serializationPlugins.push(step);\n\t}\n\n\taddBuildPlugin(step: TransactionPlugin) {\n\t\tthis.#buildPlugins.push(step);\n\t}\n\n\taddIntentResolver(intent: string, resolver: TransactionPlugin) {\n\t\tif (this.#intentResolvers.has(intent) && this.#intentResolvers.get(intent) !== resolver) {\n\t\t\tthrow new Error(`Intent resolver for ${intent} already exists`);\n\t\t}\n\n\t\tthis.#intentResolvers.set(intent, resolver);\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#data.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#data.sender) {\n\t\t\tthis.#data.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: InferInput<typeof TransactionExpiration> | null) {\n\t\tthis.#data.expiration = expiration ? parse(TransactionExpiration, expiration) : null;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#data.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#data.gasConfig.budget = String(budget);\n\t}\n\n\tsetGasBudgetIfNotSet(budget: number | bigint) {\n\t\tif (this.#data.gasData.budget == null) {\n\t\t\tthis.#data.gasConfig.budget = String(budget);\n\t\t}\n\t}\n\n\tsetGasOwner(owner: string) {\n\t\tthis.#data.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: ObjectRef[]) {\n\t\tthis.#data.gasConfig.payment = payments.map((payment) => parse(ObjectRefSchema, payment));\n\t}\n\n\t#data: TransactionDataBuilder;\n\n\t/** @deprecated Use `getData()` instead. */\n\tget blockData() {\n\t\treturn serializeV1TransactionData(this.#data.snapshot());\n\t}\n\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tgetData() {\n\t\treturn this.#data.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transactions via postMessage\n\tget pure(): ReturnType<typeof createPure<Argument>> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure<Argument>((value): Argument => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#addInput('pure', {\n\t\t\t\t\t\t$kind: 'Pure',\n\t\t\t\t\t\tPure: {\n\t\t\t\t\t\t\tbytes: value.toBase64(),\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#addInput(\n\t\t\t\t\t'pure',\n\t\t\t\t\tis(NormalizedCallArg, value)\n\t\t\t\t\t\t? parse(NormalizedCallArg, value)\n\t\t\t\t\t\t: value instanceof Uint8Array\n\t\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t\t: { $kind: 'UnresolvedPure', UnresolvedPure: { value } },\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor() {\n\t\tconst globalPlugins = getGlobalPluginRegistry();\n\t\tthis.#data = new TransactionDataBuilder();\n\t\tthis.#buildPlugins = [...globalPlugins.buildPlugins.values()];\n\t\tthis.#serializationPlugins = [...globalPlugins.serializationPlugins.values()];\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas() {\n\t\treturn { $kind: 'GasCoin' as const, GasCoin: true as const };\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject: ReturnType<\n\t\ttypeof createObjectMethods<{ $kind: 'Input'; Input: number; type?: 'object' }>\n\t> = createObjectMethods(\n\t\t(value: TransactionObjectInput): { $kind: 'Input'; Input: number; type?: 'object' } => {\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn this.object(this.add(value as (tx: Transaction) => TransactionObjectArgument));\n\t\t\t}\n\n\t\t\tif (typeof value === 'object' && is(ArgumentSchema, value)) {\n\t\t\t\treturn value as { $kind: 'Input'; Input: number; type?: 'object' };\n\t\t\t}\n\n\t\t\tconst id = getIdFromCallArg(value);\n\n\t\t\tconst inserted = this.#data.inputs.find((i) => id === getIdFromCallArg(i));\n\n\t\t\t// Upgrade shared object inputs to mutable if needed:\n\t\t\tif (\n\t\t\t\tinserted?.Object?.SharedObject &&\n\t\t\t\ttypeof value === 'object' &&\n\t\t\t\tvalue.Object?.SharedObject\n\t\t\t) {\n\t\t\t\tinserted.Object.SharedObject.mutable =\n\t\t\t\t\tinserted.Object.SharedObject.mutable || value.Object.SharedObject.mutable;\n\t\t\t}\n\n\t\t\treturn inserted\n\t\t\t\t? { $kind: 'Input', Input: this.#data.inputs.indexOf(inserted), type: 'object' }\n\t\t\t\t: this.#addInput(\n\t\t\t\t\t\t'object',\n\t\t\t\t\t\ttypeof value === 'string'\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t$kind: 'UnresolvedObject',\n\t\t\t\t\t\t\t\t\tUnresolvedObject: { objectId: normalizeSuiAddress(value) },\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: value,\n\t\t\t\t\t);\n\t\t},\n\t);\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t#fork() {\n\t\tconst fork = new Transaction();\n\n\t\tfork.#data = this.#data;\n\t\tfork.#serializationPlugins = this.#serializationPlugins;\n\t\tfork.#buildPlugins = this.#buildPlugins;\n\t\tfork.#intentResolvers = this.#intentResolvers;\n\t\tfork.#pendingPromises = this.#pendingPromises;\n\t\tfork.#availableResults = new Set(this.#availableResults);\n\t\tfork.#added = this.#added;\n\t\tthis.#inputSection.push(fork.#inputSection);\n\t\tthis.#commandSection.push(fork.#commandSection);\n\n\t\treturn fork;\n\t}\n\n\t/** Add a transaction to the transaction */\n\n\tadd<T extends Command>(command: T): TransactionResult;\n\tadd<T extends void | TransactionResultArgument | TransactionArgument | Command>(\n\t\tthunk: (tx: Transaction) => T,\n\t): T;\n\tadd<T extends TransactionResultArgument | void>(\n\t\tasyncTransactionThunk: AsyncTransactionThunk<T>,\n\t): T;\n\tadd(command: Command | AsyncTransactionThunk | ((tx: Transaction) => unknown)): unknown {\n\t\tif (typeof command === 'function') {\n\t\t\tif (this.#added.has(command)) {\n\t\t\t\treturn this.#added.get(command);\n\t\t\t}\n\n\t\t\tconst fork = this.#fork();\n\t\t\tconst result = command(fork);\n\n\t\t\tif (!(result && typeof result === 'object' && 'then' in result)) {\n\t\t\t\tthis.#availableResults = fork.#availableResults;\n\t\t\t\tthis.#added.set(command, result);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tconst placeholder = this.#addCommand({\n\t\t\t\t$kind: '$Intent',\n\t\t\t\t$Intent: {\n\t\t\t\t\tname: 'AsyncTransactionThunk',\n\t\t\t\t\tinputs: {},\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tresultIndex: this.#data.commands.length,\n\t\t\t\t\t\tresult: null as TransactionResult | null,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.#pendingPromises.add(\n\t\t\t\tPromise.resolve(result as Promise<TransactionResult>).then((result) => {\n\t\t\t\t\tplaceholder.$Intent.data.result = result;\n\t\t\t\t}),\n\t\t\t);\n\t\t\tconst txResult = createTransactionResult(() => placeholder.$Intent.data.resultIndex);\n\t\t\tthis.#added.set(command, txResult);\n\t\t\treturn txResult;\n\t\t} else {\n\t\t\tthis.#addCommand(command);\n\t\t}\n\n\t\treturn createTransactionResult(this.#data.commands.length - 1);\n\t}\n\n\t#addCommand<T extends Command>(command: T) {\n\t\tconst resultIndex = this.#data.commands.length;\n\t\tthis.#commandSection.push(command);\n\t\tthis.#availableResults.add(resultIndex);\n\t\tthis.#data.commands.push(command);\n\n\t\tthis.#data.mapCommandArguments(resultIndex, (arg) => {\n\t\t\tif (arg.$kind === 'Result' && !this.#availableResults.has(arg.Result)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { Result: ${arg.Result} } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'NestedResult' && !this.#availableResults.has(arg.NestedResult[0])) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Result { NestedResult: [${arg.NestedResult[0]}, ${arg.NestedResult[1]}] } is not available to use in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (arg.$kind === 'Input' && arg.Input >= this.#data.inputs.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Input { Input: ${arg.Input} } references an input that does not exist in the current transaction`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\treturn command;\n\t}\n\n\t#addInput<T extends 'pure' | 'object'>(type: T, input: CallArg) {\n\t\tthis.#inputSection.push(input);\n\t\treturn this.#data.addInput(type, input);\n\t}\n\n\t#normalizeTransactionArgument(arg: TransactionArgument | SerializedBcs<any>) {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn this.#resolveArgument(arg as TransactionArgument);\n\t}\n\n\t#resolveArgument(arg: TransactionArgument): Argument {\n\t\tif (typeof arg === 'function') {\n\t\t\tconst resolved = this.add(arg as never);\n\n\t\t\tif (typeof resolved === 'function') {\n\t\t\t\treturn this.#resolveArgument(resolved);\n\t\t\t}\n\n\t\t\treturn parse(ArgumentSchema, resolved);\n\t\t}\n\n\t\treturn parse(ArgumentSchema, arg);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins<\n\t\tconst Amounts extends (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t>(coin: TransactionObjectArgument | string, amounts: Amounts) {\n\t\tconst command = Commands.SplitCoins(\n\t\t\ttypeof coin === 'string' ? this.object(coin) : this.#resolveArgument(coin),\n\t\t\tamounts.map((amount) =>\n\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t),\n\t\t);\n\t\tthis.#addCommand(command);\n\t\treturn createTransactionResult(this.#data.commands.length - 1, amounts.length) as Extract<\n\t\t\tArgument,\n\t\t\t{ Result: unknown }\n\t\t> & {\n\t\t\t[K in keyof Amounts]: Extract<Argument, { NestedResult: unknown }>;\n\t\t};\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.MergeCoins(\n\t\t\t\tthis.object(destination),\n\t\t\t\tsources.map((src) => this.object(src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tCommands.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackage: packageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackage: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackage: packageId,\n\t\t\t\tticket: this.object(ticket),\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\t...input\n\t}:\n\t\t| {\n\t\t\t\tpackage: string;\n\t\t\t\tmodule: string;\n\t\t\t\tfunction: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }\n\t\t| {\n\t\t\t\ttarget: string;\n\t\t\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\t\t\ttypeArguments?: string[];\n\t\t  }) {\n\t\treturn this.add(\n\t\t\tCommands.MoveCall({\n\t\t\t\t...input,\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t} as Parameters<typeof Commands.MoveCall>[0]),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tCommands.TransferObjects(\n\t\t\t\tobjects.map((obj) => this.object(obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\telements,\n\t}: {\n\t\telements: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tCommands.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\telements: elements.map((obj) => this.object(obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated Use toJSON instead.\n\t * For synchronous serialization, you can use `getData()`\n\t * */\n\tserialize() {\n\t\treturn JSON.stringify(serializeV1TransactionData(this.#data.snapshot()));\n\t}\n\n\tasync toJSON(options: SerializeTransactionOptions = {}): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tconst fullyResolved = this.isFullyResolved();\n\t\treturn JSON.stringify(\n\t\t\tparse(\n\t\t\t\tSerializedTransactionDataV2Schema,\n\t\t\t\tfullyResolved\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t...this.#data.snapshot(),\n\t\t\t\t\t\t\tdigest: this.#data.getDigest(),\n\t\t\t\t\t\t}\n\t\t\t\t\t: this.#data.snapshot(),\n\t\t\t),\n\t\t\t(_key, value) => (typeof value === 'bigint' ? value.toString() : value),\n\t\t\t2,\n\t\t);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransaction(bytes);\n\t}\n\n\t/**\n\t *  Ensures that:\n\t *  - All objects have been fully resolved to a specific version\n\t *  - All pure inputs have been serialized to bytes\n\t *  - All async thunks have been fully resolved\n\t *  - All transaction intents have been resolved\n\t * \t- The gas payment, budget, and price have been set\n\t *  - The transaction sender has been set\n\t *\n\t *  When true, the transaction will always be built to the same bytes and digest (unless the transaction is mutated)\n\t */\n\tisFullyResolved() {\n\t\tif (!this.#data.sender) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#pendingPromises.size > 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.#data.commands.some((cmd) => cmd.$Intent)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (needsTransactionResolution(this.#data, {})) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildTransactionOptions = {}): Promise<Uint8Array<ArrayBuffer>> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.build({\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: ClientWithCoreApi;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.prepareForSerialization(options);\n\t\tawait this.#prepareBuild(options);\n\t\treturn this.#data.getDigest();\n\t}\n\n\t/**\n\t * Prepare the transaction by validating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepareBuild(options: BuildTransactionOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#data.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tawait this.#runPlugins([...this.#buildPlugins, resolveTransactionPlugin], options);\n\t}\n\n\tasync #runPlugins(plugins: TransactionPlugin[], options: SerializeTransactionOptions) {\n\t\ttry {\n\t\t\tconst createNext = (i: number) => {\n\t\t\t\tif (i >= plugins.length) {\n\t\t\t\t\treturn () => {};\n\t\t\t\t}\n\t\t\t\tconst plugin = plugins[i];\n\n\t\t\t\treturn async () => {\n\t\t\t\t\tconst next = createNext(i + 1);\n\t\t\t\t\tlet calledNext = false;\n\t\t\t\t\tlet nextResolved = false;\n\n\t\t\t\t\tawait plugin(this.#data, options, async () => {\n\t\t\t\t\t\tif (calledNext) {\n\t\t\t\t\t\t\tthrow new Error(`next() was call multiple times in TransactionPlugin ${i}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcalledNext = true;\n\n\t\t\t\t\t\tawait next();\n\n\t\t\t\t\t\tnextResolved = true;\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!calledNext) {\n\t\t\t\t\t\tthrow new Error(`next() was not called in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!nextResolved) {\n\t\t\t\t\t\tthrow new Error(`next() was not awaited in TransactionPlugin ${i}`);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tawait createNext(0)();\n\t\t} finally {\n\t\t\tthis.#inputSection = this.#data.inputs.slice();\n\t\t\tthis.#commandSection = this.#data.commands.slice();\n\t\t\tthis.#availableResults = new Set(this.#commandSection.map((_, i) => i));\n\t\t}\n\t}\n\n\tasync #waitForPendingTasks() {\n\t\twhile (this.#pendingPromises.size > 0) {\n\t\t\tconst newPromise = Promise.all(this.#pendingPromises);\n\t\t\tthis.#pendingPromises.clear();\n\t\t\tthis.#pendingPromises.add(newPromise);\n\t\t\tawait newPromise;\n\t\t\tthis.#pendingPromises.delete(newPromise);\n\t\t}\n\t}\n\n\t#sortCommandsAndInputs() {\n\t\tconst unorderedCommands = this.#data.commands;\n\t\tconst unorderedInputs = this.#data.inputs;\n\n\t\tconst orderedCommands = (this.#commandSection as Command[]).flat(Infinity);\n\t\tconst orderedInputs = (this.#inputSection as CallArg[]).flat(Infinity);\n\n\t\tif (orderedCommands.length !== unorderedCommands.length) {\n\t\t\tthrow new Error('Unexpected number of commands found in transaction data');\n\t\t}\n\n\t\tif (orderedInputs.length !== unorderedInputs.length) {\n\t\t\tthrow new Error('Unexpected number of inputs found in transaction data');\n\t\t}\n\n\t\tconst filteredCommands = orderedCommands.filter(\n\t\t\t(cmd) => cmd.$Intent?.name !== 'AsyncTransactionThunk',\n\t\t);\n\n\t\tthis.#data.commands = filteredCommands;\n\t\tthis.#data.inputs = orderedInputs;\n\t\tthis.#commandSection = filteredCommands;\n\t\tthis.#inputSection = orderedInputs;\n\t\tthis.#availableResults = new Set(filteredCommands.map((_, i) => i));\n\n\t\tfunction getOriginalIndex(index: number): number {\n\t\t\tconst command = unorderedCommands[index];\n\t\t\tif (command.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\tconst result = command.$Intent.data.result as TransactionResult | null;\n\n\t\t\t\tif (result == null) {\n\t\t\t\t\tthrow new Error('AsyncTransactionThunk has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn getOriginalIndex(result.Result);\n\t\t\t}\n\n\t\t\tconst updated = filteredCommands.indexOf(command);\n\n\t\t\tif (updated === -1) {\n\t\t\t\tthrow new Error('Unable to find original index for command');\n\t\t\t}\n\n\t\t\treturn updated;\n\t\t}\n\n\t\tthis.#data.mapArguments((arg) => {\n\t\t\tif (arg.$kind === 'Input') {\n\t\t\t\tconst updated = orderedInputs.indexOf(unorderedInputs[arg.Input]);\n\n\t\t\t\tif (updated === -1) {\n\t\t\t\t\tthrow new Error('Input has not been resolved');\n\t\t\t\t}\n\n\t\t\t\treturn { ...arg, Input: updated };\n\t\t\t} else if (arg.$kind === 'Result') {\n\t\t\t\tconst updated = getOriginalIndex(arg.Result);\n\n\t\t\t\treturn { ...arg, Result: updated };\n\t\t\t} else if (arg.$kind === 'NestedResult') {\n\t\t\t\tconst updated = getOriginalIndex(arg.NestedResult[0]);\n\n\t\t\t\treturn { ...arg, NestedResult: [updated, arg.NestedResult[1]] };\n\t\t\t}\n\n\t\t\treturn arg;\n\t\t});\n\n\t\tfor (const [i, cmd] of unorderedCommands.entries()) {\n\t\t\tif (cmd.$Intent?.name === 'AsyncTransactionThunk') {\n\t\t\t\ttry {\n\t\t\t\t\tcmd.$Intent.data.resultIndex = getOriginalIndex(i);\n\t\t\t\t} catch {\n\t\t\t\t\t// If async thunk did not return a result, this will error, but is safe to ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tasync prepareForSerialization(options: SerializeTransactionOptions) {\n\t\tawait this.#waitForPendingTasks();\n\t\tthis.#sortCommandsAndInputs();\n\t\tconst intents = new Set<string>();\n\t\tfor (const command of this.#data.commands) {\n\t\t\tif (command.$Intent) {\n\t\t\t\tintents.add(command.$Intent.name);\n\t\t\t}\n\t\t}\n\n\t\tconst steps = [...this.#serializationPlugins];\n\n\t\tfor (const intent of intents) {\n\t\t\tif (options.supportedIntents?.includes(intent)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!this.#intentResolvers.has(intent)) {\n\t\t\t\tthrow new Error(`Missing intent resolver for ${intent}`);\n\t\t\t}\n\n\t\t\tsteps.push(this.#intentResolvers.get(intent)!);\n\t\t}\n\n\t\tsteps.push(namedPackagesPlugin());\n\n\t\tawait this.#runPlugins(steps, options);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["UpgradePolicy", "NormalizedCallArg", "TransactionExpiration", "resolved", "_ClientCache", "_cache", "url", "__privateAdd", "__privateSet", "__privateGet", "$Intent", "ObjectArg", "TransactionExpiration", "chunk", "object", "inputs", "getClient", "object", "_Transaction", "__privateAdd", "__privateGet", "__privateMethod", "__privateSet", "result"]
}
